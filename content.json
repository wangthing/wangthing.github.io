{"pages":[],"posts":[{"title":"CSS-实现三栏布局","text":"","link":"/2020/02/09/CSS-%E5%AE%9E%E7%8E%B0%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"},{"title":"CSS-盒模型","text":"问题 基本概念：标准模型+IE模型 标准模型和IE模型的区别 CSS如何设置这两种模型 JS如何设置获取盒模型对应的宽度和高度 根据盒模型解释边距重叠 BFC（编剧重叠解决方案） ##IE模型和标准模型 标准模型：宽度和高度是content的大小,设置方法 box-sizing:content-box IE模型： 宽高是content + padding + boeder，也就是我们说的 boeder-box JS如何获取盒模型对应的高和宽 dom.style.width/height 但是这样只能取得内联样式 dom.currentStyle.width/height 可以获取所有样式计算之后的属性，但是只能在IE window.getComputedStyle(dom).width/heiht 兼容性更好，火狐谷歌等浏览器都可以 dom.getBoundingClientReact().width/height 可以获取到元素局浏览器视口的绝对位置 BFC(边距重叠) BFC的基本概念 BFC的原理 如何创建BFC BFC的使用场景有哪些 相邻兄弟元素边距重叠","link":"/2020/02/10/CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"title":"CSS世界-温和的padding","text":"CSS世界-温和的padding​ 在CSS世界的元素中，之所以说 padding 是性格温和的，是因为我们在使用padding 的时候很少会出现我们意想不到的情况，基本上就是我们想要的样子，就给人一种 padding 不怎么会发脾气一样，很好相处，也愿意使用。 1. padding 和元素尺寸的关系​ 除了 IE 有怪异盒模型 之外，大部分浏览器CSS 中默认的 box-sizing 是 content-box ，所以使用padding 会增加元素的尺寸 1234567.box{ padding: 20px; width: 100px; }&lt;div&gt;宽度：width+padding-left+padding-right=140px&lt;/div&gt; ​ 这似乎和我们在现实世界所认识的宽度有所违背，就会导致我们设置 box-sizing-border-box 来达到我们所预期的宽度应该是100px，而 content 就变成就60px；甚至会在全局重置样式加入这样的声明，这样的做法是不推荐的。因为 border-box 只能让我们免去padding 的影响，但是 margin 带来的影响是无法消除的，没有 margin-box这个东西 。可以尝试在外面套个父级元素定宽来达到我们想要的效果。 1234567891011.father{ width:120px;}.son{ padding:12px; margin:6px;}&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; ​ 而 box-sizing:border-box 的正确用法应该是在我们使用原生的 input textarea等替换元素时，我们在设置width：100% 去填满父级元素是，他们是有 border 和 padding 的，我们会加 padding 让文本输入光标有一定的距离，默认的 content-box 会导致宽度溢出 ，这时候就可以通过 border-box 来达到我们想要的效果。 1234567 .text{ width: 100%; box-sizing: border-box; padding: 12px; }&lt;textarea name=&quot;&quot; class=&quot;text&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; ​ 并不是设置了 border-box 元素的尺寸就不会变化了，当 padding足够大的时候， width 也就突然失效了。 12345.box { width: 80px; padding: 20px 60px; box-sizing: border-box; } 此时 div 的宽度变成了 120px（60*2）。 ​ 上面是对于块状元素而发生的表现，对于内联元素（不包括 img 等替换元素）表现则有些不同 1234a{ padding:50px; background-color:#df0000;} 很明显已经影响到其他元素的显示了，但是对上下元素的布局没有发生影响，只是在垂直方向发生了层叠 ​ CSS 中还有许多这样类似的不会影响其他元素的布局但是会出现层叠效果的现象，比如 relative 定位、盒子阴影 box-shadow 、以及 outline 。这些层叠现象看上去都类似，但是实际上有区别。主要分为两类： box-shadow 和 outline 属于纯视觉层叠 inline 元素padding 层叠则属于后者。 区分方式很简单，如果父容器设置 overflow：auto ，层叠区域超出父容器的时候，没有滚动条的是纯视觉效果；如果出现滚动条的，则是会影响尺寸和布局的。 可见内联元素 padding 对视觉层和布局层具有双重影响 内联元素 padding 有用对我们CSS开发有什么帮助呢？ 增加文字链接的点击区域，而不是去设置 inline-block 增加不必要的行间距 创建一个高度可控的分隔内容： 123456789a+a::before{ content: ''; font-size: 0px; padding: 12px 3px 1px; border-left: 1px solid gray; margin-left: 6px; }&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt; 2. padding 的百分比值关于padding 的属性值有以下几点： 和 margin 不同， padding 的属性值是不支持负值 padding 虽然支持百分比，但是和 height 等属性的百分比计算规则有差异：无论是水平方向还是垂直方向都是相对于宽度来计算的。 123456789实现等比例矩形div{ padding：50% 50%;}div{ padding: 25% 50%;} y用来实现顶部头图，比例5:1自适应12345678910111213141516.div1{ position: relative; padding: 10% 45%; background-color: chocolate; } .div1&gt;img{ position: absolute; top: 0; left: 0; height: 100%; width: 100%; } &lt;div class=&quot;div1&quot;&gt; &lt;img src=&quot;../../images/v2-de9685e11d1f46870d5330d48a20076b_hd.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; padding 百分比值应用在内联元素当中是什么效果 同样相对于宽度来计算 默认的高度和宽度细节有差异 padding 会断行 下面是一个内联元素 padding 断行的例子： 12345678.box{ border:2px solid #00cdfa;}span{ background-color:gray; padding:50%}&lt;span&gt;这里有六个字&lt;/span&gt; 效果非常诡异，我也没搞清楚是怎么会出现这样的效果。如果 span 元素里面没有内容，会发现也并不是等宽高的正方形，原因是： 内联元素的垂直 padding 会让’幽灵空白节点‘ 出现 。可以设置 font-size:0来消除这个空白节点带来的影响 标签元素内置的 padding这是一些关于 padding 的小秘密 ol li 列表内置 padding-left 单位是 px 当字体设置很大时，数字或者点会跑到外面去 当字体设置的很小时，数字或者点会里左边距离很大 当字体在 12-14px时，可以给 ol/ul 设置一个 22px的 padding-left 如果要求比较高，使用content 计数器来模拟是一个不错的选择 很多表单元素都内置了 padding 所有浏览器的 input textarea 输入框内置了 padding 所有浏览器的 button 按钮内置了 padding 部分浏览器 select 下拉框内置了 padding ，Firefox IE8及以上的浏览器可以设置 padding 所有浏览器 radio checkbox 单复选框无内置 padding button 按钮元素的 padding 最难控制 由于 button 按钮元素在不同浏览器下 padding 的表象各不相同，我们大多数时候会选择用标签 来模拟按钮，但是在表单中 button 是自带交互行为的，使用标签是无法模拟的。 1234567891011&lt;button id=&quot;btn&quot;&gt;&lt;/button&gt; &lt;label for=&quot;btn&quot;&gt;按钮&lt;/label&gt; button { position: absolute; clip: rect(0 0 0 0); } label { display: inline-block; line-height: 20px; padding: 10px; } 使用上面的方法，在保留了良好的语义性的同时，UI兼容性也非常好 padding 与图形绘制padding 属性和 background-clip 属性配合，可以在有限的标签下实现一些CSS图形绘制效果，下面是两个例子： “三道杠” 分类图标效果，此效果在移动端比较常见 123456789.icon-menu { display: inline-block; width: 140px; height: 10px; padding: 35px 0; border-top: 10px solid; border-bottom: 10px solid; background-color: currentColor; background-clip: content-box; } 仅用一个标签，不用伪元素实现双层圆效果 123456789.icon-dot { display: inline-block; width: 100px; height: 100px; padding: 10px; border: 10px solid; border-radius: 50%; background-color: currentColor; background-clip: content-box; }","link":"/2020/01/14/CSS%E4%B8%96%E7%95%8C-%E6%B8%A9%E5%92%8C%E7%9A%84padding/"},{"title":"DOM 事件","text":"DOM事件类 基本概念：DOM事件的级别 DOM事件模型 DOM事件流 描述DOM事件捕获的具体流程 Event对象的常见应用 自定义事件 DOM事件的级别 DOM0 123element.onclick = function () { //do something} DOM2 123element.addEventListener('click',function () {}, false)//最后一个参数为true代表捕获阶段触发，false代表冒泡阶段触发 DOM3 1element.addEventListener('keyup', function () {}, false) DOM1标准也存在，只是没有定义和事件有关的 事件模型先捕获再冒泡 事件流浏览器在和用户交互的过程中，事件产生的流程 第一阶段：捕获 第二阶段：事件通过捕获到达目标阶段 第三阶段：从目标阶段通过冒泡传递到window对象 捕获： 12345678910111213141516171819202122232425 window =&gt; document =&gt; html =&gt; body =&gt; target var event = document.getElementById('event'); window.addEventListener('click',function () { console.log('window capture!'); }, true) document.addEventListener('click',function () { console.log(&quot;document capture&quot;); }, true) document.documentElement.addEventListener('click', function () { console.log(&quot;HTML capture!&quot;); }, true) document.body.addEventListener('click',function (e) { console.log(&quot;body capture&quot;); },true) event.addEventListener('click', function (e) { console.log(&quot;event&quot;); }, true) window capture! document capture HTML capture!7 body capture event 冒泡和上面相反 Event对象的常见应用 event.preventDefault() 阻止默认的行为，比如 a标签的页面跳转 1234567var link = document.getElementById('link') link.onclick = function (e) { e.preventDefault(); } form.onclick = function (e) { e.preventDefault() } ​ event.stopPropagation() event.stopImmediatePropogation() 下面这两个主要是用于事件委托 event.currentTarget event.target 自定义事件1234567var event = new Event('custome')var btn1 = document.getElementById('btn1')btn1.addEventListener('custome', function () { console.log('custome event')})btn1.dispatchEvent(event) 还有 customEvent 可以自定义事件，并且可以传递数据 123456789101112// 首先创建一个事件let myEvent = new CustomEvent(&quot;userLogin&quot;, { detail: { username: &quot;davidwalsh&quot; }}); btn.addEventListener(&quot;userLogin&quot;, function(e) { console.info(&quot;Event is: &quot;, e); console.info(&quot;Custom data is: &quot;, e.detail); })myElement.dispatchEvent(myEvent);","link":"/2020/02/09/DOM-%E4%BA%8B%E4%BB%B6/"},{"title":"ES6基本语法","text":"模块化 babel.jsexport default 是一个的话，就可以直接引入123456789//utils.jsexport default { name:&quot;Wang Junping&quot;}//index.jsimport utils from './utils.js'console.log(utils.name) //报错 使用 babel-node index.js就没问题了 我觉得应该是不支持 import语法吧 ##Babel 使用 1. 下载babel：cnpm install –save-dev babel-core babel-preset-es2015 babel-preset-latest 2. 在根目录下新建 `.babelrc` 文件并写入 1234{ &quot;presets&quot;: [&quot;es2015&quot;,&quot;latest&quot;], &quot;plugins&quot;: []} 下载babel-cli npm install -g babel-cli 在src文件夹下新建index.js,用ES6箭头函数语法写代码1var arr = [1,2,3].map((item) =&gt; item+1) 命令行输入babel ./src/index.js 开发环境- webpack npm install webpack babel-loader –save-dev 配置 webpack.config.js 配置 package.json中的scripts 运行 npm start Class和普通构造函数有什么区别JS构造函数1234567891011function MathHandle (x,y) { this.x = x; this.y = y;}MathHandle.prototype.add = function (x,y) { return this.x + this.y;}var m = new MathHandle(2,3)console.log(m.add()) //5 Class语法1234567891011121314151617class MathHandle { constructor(x,y) { this.x = x; this.y = y; } add() { return this.x + this.y; }}const m = new MathHandle(1,2);console.log(m.add()) //3console.log(typeof MathHandle2) // &quot;function&quot;console.log(MathHandle2.prototype.constructor === MathHandle2) //trueconsole.log(m2.__proto__ === MathHandle2.prototype) //true 所以Class本身是一个语法糖，本质还是构造函数继承-JS1234567891011121314151617function Animal () { this.eat = function () { console.log(&quot;animal eat&quot;) }}//狗function Dog () { this.bark = function () { console,log(&quot;dog bark&quot;) }}Dog.prototy = new Animal()//哈士奇var hashiqi = new Dog() 继承 Class12345678910111213141516171819202122class Animal { constructor(name) { this.name = name } eat() { console.log(`${this.name} eat`) }}class Dog extends Animal { constructor(name) { super(name) //只要是extends的，super()是一定要加上的 this.name = name } say() { console.log(`${this.name} eat `) }}const dog = new Dog(&quot;哈士奇&quot;)dog.say() //哈士奇 bark dog.eat() //哈士奇 eat 总结 Class 在语法上更加贴合面向对象的写法 Class 在实现继承上更加易读、理解 更易于写Java等后端语言的使用 本质是语法糖，还是使用 prototype Promise 的基本使用解决Callback Hell12345678910111213141516171819202122function loadImg (src,callback,fail) { var img = document.createElement('img'); img.onload = function () { callback(img) } img.onerror = function () { fail() } img.src = src;}var src = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;loadImg(src,function (img) { alert(img.width)},function () {}) 使用 Promise语法123456789101112131415161718192021222324252627function loadImg (src) { const promise = new Promise(function(resolve,reject) { var img = document.createElement(&quot;img&quot;) img.onload = function () { resolve(img) } img.onerror = function () { reject() } img.src = src }) return promise}var src = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;loadImg(src).then(function (img) { alert(img.width) document.body.append(img)},function () { alert(&quot;loading fail&quot;)}).catch(function () { alert(&quot;error&quot;)}) 总结一下ES6 其他常用功能 let/const 多行字符串/模板变量 ${} 解构赋值 块级作用域 函数默认参数 箭头函数（清晰了this指向）","link":"/2020/01/06/ES6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"MVVM设计框架-vue如何实现的","text":"MVVM设计框架##问题 说一下使用jQuery和使用vue、react等框架的区别 说一下对MVVM的理解 vue 中如何实现响应式 vue 中如何解析模板 vue 的整个实现流程 1. 说一下使用jQuery和使用vue、react等框架的区别 jQuery 实现 todo-list vue 实现 todo-list jQuery和框架的区别 jQuery 实现 todo-list12345678910111213141516171819202122232425&lt;body&gt; &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;text-title&quot;&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var textTitle = $(&quot;#text-title&quot;) var btn = $(&quot;#btn&quot;) var list = $(&quot;#list&quot;) btn.click(function () { // dom 和数据耦合在一起 var title = textTitle.val() if(!title){ return; } var li = $(`&lt;li&gt;${title}&lt;/li&gt;`) list.append(li) textTitle.val('') })&lt;/script&gt; vue 实现 todo-list12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;title&quot;&gt; &lt;button @click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ // 数据驱动视图 title:'', list:[] }, methods: { add(){ // 修改数据，视图的修改vue会帮你做 // 利用diff算法去优化了DOM操作 this.list.push(this.title) this.title = &quot;&quot; } }, })&lt;/script&gt; 这两个案例可以看出来两者的区别 数据和视图的分离，解耦（开放封闭原则） 以数据驱动视图，只关心数据变化，DOM操作被封装 2. 说一下对 MVVM 的理解 什么是MVC Model 数据 View 用户视图 Controller 控制器 MVVM Model 数据 Data View 视图HTML ViewModel 连接View和Model MVVM不算是一种创新 但是其中的 ViewModel 是一种创新 真正的结合前端场景应用的创建 MVVM框架的三大要素 响应式：vue如何监听到 data 的每个属性的变化？ 模板引擎： vue的模板如何被解析，指令如何处理？ 渲染： vue的模板如何被渲染成html？以及渲染过程 3. vue中如何实现响应式 什么是响应式 修改data属性之后，vue立刻监听到 data 属性被代理到vm上 演示 Object.defineProperty 将data属性代理到vm上 模拟 利用Object.defineProperty模拟响应式12345678910111213141516171819202122var obj = { name: &quot;wang&quot;, age: 22}function Proxy (obj) { Object.keys(obj).forEach( (key) =&gt; { //这里是核心，把obj数据代理到w上 Object.defineProperty(vm,key,{ get: function () { return obj[key]; }, set: function (newValue) { if(newValue === obj[key]){ return obj[key] } else { obj[key] = newValue } } }) })} 4. Vue中如何解析模板 模板是什么 render 函数 render 函数与 vdom 模板是什么1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;title&quot;&gt; &lt;button @click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 模板的本质就是字符串 是有逻辑的字符串，v-if、v-for。。。 还可以嵌入JS变量 类似html格式，但是有很大区别 最终会被转换成html来显示 最终必须转换成JS代码（有逻辑，JS是图灵完备语言） 需要一个JS函数（render函数） render函数 with的用法12345678910111213141516171819202122232425var obj = { name: '张三', age: 20, getAddress: function () { alert('nanchang') } }//不用withfunction fn() { alert(obj.name) alert(obj.age) obj.getAddress()}//使用with 不建议自己实际开发的时候使用//vue 里面用了，但也只是它内部使用function fn2 () { with(obj) { alert(name) alert(age) getAddress() }} 5. render 函数和 vnode1234567891011121314vm._update(vnode) { const preVnode = vm._vnode vm._vnodee = vnode if(!preVnode) { vm.$el = vm.__patch__(vm.$el, vnoded) } else { vm.$el = vm.__patch__(preVnode, vnoded) }}function updateComponent () { //vm._render 即上面的render 函数，并返回vnode vm._update(vm._render())} updateComponent中实现了vdom和patch 页面首次渲染执行 updateComponent data中每次修改属性值，执行updateComponent 6. Vue 的整个实现流程 第一步： 解析模板成render函数 第二步： 响应式开始监听 第三步： 首次渲染，显示页面，且绑定依赖 为什么监听 get，只监听set不行吗 data 中有很多属性，有些会被用到，有些可能不会被用到 未走 get 中的属性， set的时候我们也无需关心 避免不必要的重新渲染 第四步： data属性变化，触发 rerender函数 根据Demo 说明123456789101112131415161718192021222324252627282930313233&lt;body&gt; //第一步： 解析模板成 render 函数 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;title&quot;&gt; &lt;button @click=&quot;add&quot;&gt;submit&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ //第二步： 响应式开始监听 将data中数据通过 Object.defineProperty 绑定到vm中 // 数据驱动视图 title:'', list:[] }, methods: { add(){ // 修改数据，视图的修改vue会帮你做 // 利用diff算法去优化了DOM操作 this.list.push(this.title) this.title = &quot;&quot; } }, })&lt;/script&gt; //第三步： 首次渲染，显示页面，且绑定依赖","link":"/2020/01/08/MVVM%E8%AE%BE%E8%AE%A1%E6%A1%86%E6%9E%B6-vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/"},{"title":"h常见命令","text":"一、 新建、删除文章新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。 新建文章 1$ sudo hexo new &quot;new-article&quot; 文字的标题也可以在对应的 md 文件中修改之后在source/_posts目录下面，多了一个new-article.md的文件。 删除文章 123* 删除 db.json* 删除 xx.md 文章, 文件夹中搜索标题 xx 相关文件，html文件一并删除* 执行 hexo clean 、hexo g 、hexo d 即可 二、清理缓存清理缓存文件 db.json 和 已生成的静态文件 public当你对站点的修改怎么都不起作用时，执行该命令 1$ sudo hexo clean 三、生成静态文件1$ sudo hexo generate 该命令也可以简写成 1$ sudo hexo g 四、启动服务器启动本地服务服务器，预览网页。默认情况下地址为 http://localhost:4000/ 1$ sudo hexo server 简写 1$ sudo hexo s 五、部署网站生成网站静态文件，部署到远程仓库 1$ sudo hexo deploy 简写 1$ sudo hexo d","link":"/2019/12/23/hexo%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"},{"title":"js中为什么异步和单线程，怎么处理异步","text":"异步 什么是单线程，和异步有什么关系 什么是event-loop 是否使用过jQuery的Deferred Promise的基本使用和原理 介绍一下async/await（和promise的区别、联系） 总结一下当前JS解决异步的方案 1. 什么是单线程，和异步的关系 单线程-只有一个线程，同时只能做一件事 原因：避免DOM渲染的冲突 浏览器需要渲染DOM JS可以修改DOM结构 JS执行的时候，浏览器DOM渲染会暂停 两端JS也不能同时执行（都修改DOM就冲突了） webworker支持多线程，但不能访问DOM（可以说明单线程目的是为了避免DOM渲染冲突） 解决方案（单线程）-异步 123456789&lt;script&gt; var i,sum=0; console.log(&quot;start&quot;); for(i = 0; i &lt; 1000000000; i++){ sum++ } //必须等for循环执行完，才会执行下面的代码 alert(&quot;hello&quot;) //必须点击确认，才会执行下面的 console.log(sum);&lt;/script&gt; 解决方案–异步callback123456789101112131415161718console.log('start-1')setTimeout (function () { //this is a callback console.log('start-2')},1000)// 先把定时器放在一边，继续执行下面的console.log('start-3')console.log('end')//ajaxconsole.log('start')$.ajax({ url:&quot;xxx&quot;, success: function (res) { //this is a callback console.log(res) }})console.log('end') 存在的问题 没有按照书写方式执行，可读性查 callback hell的问题，不利于维护，耦合度太高 2. 什么是event-loop 事件轮询，JS实现异步的具体解决方案 同步代码，直接执行 异步函数先放在 异步队列当中 待同步函数执行完毕，轮询执行 异步队列的函数 12345678setTimeout(function () { console.log(1)},0) //虽然是0ms，但是会先加入异步队列console.log(1)//结果：//2 //1 3. jQuery中的Deferred jQuery 1.5的变化（加入了Deferred） 使用jQuery Deferred 初步引入Promise概念 无法改变JS异步和单线程的本质 只能从写法上杜绝 callback 这种形式 它是一种语法糖形式，但是解耦了代码 很好的体现：开放封闭原则 jQuery1.5之前123456var ajax = $.ajax({ url:&quot;&quot;, success: function (res) { console.log(res) }}) jQuery1.5之后加入Deferred12345678910111213141516171819202122232425262728293031var ajax = $.ajax(&quot;./data.json&quot;)ajax.done(function () { console.log(&quot;success&quot;)}).fail(function () { console.log(&quot;fail&quot;)})function waitHandle() { var dtd = $.Deferred(); var wait = function (dtd) { var task = function () { console.log(&quot;success!&quot;) dtd.resolve() } setTimeout(task,200) return dtd.promise //返回一个promise对象 } return wait(dtd)}var w = waitHandle()$.when(w).then(function () { console.log(&quot;ok 1&quot;)}).then(function () { console.log(&quot;ok 2&quot;)}) 4. Promise 的基本使用和原理 基本语法 异常捕获 多个串联（顺序执行） Promise.all 和 Promise.race Promise的标准 解决Callback Hell12345678910111213141516171819202122function loadImg (src,callback,fail) { var img = document.createElement('img'); img.onload = function () { callback(img) } img.onerror = function () { fail() } img.src = src;}var src = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;loadImg(src,function (img) { alert(img.width)},function () {}) 使用 Promise语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function loadImg (src) { const promise = new Promise(function(resolve,reject) { var img = document.createElement(&quot;img&quot;) img.onload = function () { resolve(img) } img.onerror = function () { reject() } img.src = src }) return promise}var src = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;loadImg(src).then(function (img) { alert(img.width) document.body.append(img)},function () { alert(&quot;loading fail&quot;)}).catch(function () { alert(&quot;error&quot;)})//串联Promisevar src1 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;var src2 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;var res1 = loadImg(src1)var res2 = loadImg(src2)res1.then(function (img){ console.log(&quot;第一个图片加载完毕！&quot;) document.body.append(img) return res2}).then(function (img) { console.log(&quot;第二张图片加载完毕！&quot;) document.body.append(img)}).catch(function (err) { alert(err)}) Promise.all &amp; Promise.racePromise.all 接收一个promise 对象的数组，待全部完成之后，统一执行 success 12345678910var src1 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;var src2 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;var res1 = loadImg(src1)var res2 = loadImg(src2)Promise.all([res1,res2]).then(function (datas) { console.log(datas[0]) console.log(datas[1])}) Promise.race接收一个数组,race的意思就是比赛的意思，第一个完成的Promise对象会被作为参数传给回调函数 12345678910111213var src1 = &quot;http://www.imooc.com/static/img/index/logo_ne2w.png&quot;var src2 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;var res1 = loadImg(src1)var res2 = loadImg(src2)Promise.race([res1,res2]).then(function (data) { console.log('race',data) }).catch(function (err) { alert(err)}) 关于 async/await then只是将callback拆分了 async/await是最直接的同步写法 使用 await，函数必须用async表示 await 后面跟的是一个Promise实例 需要babel-polyfill12345678910111213141516171819202122232425function loadImg (src) { const promise = new Promise(function(resolve,reject) { var img = document.createElement(&quot;img&quot;) img.onload = function () { resolve(img) } img.onerror = function () { reject() } img.src = src }) return promise}var src1 = &quot;http://www.imooc.com/static/img/index/logo_ne2w.png&quot;var src2 = &quot;http://www.imooc.com/static/img/index/logo_new.png&quot;const load = async function () { const result1 = await loadImg(src1) console.log(result1) const result1 = await loadImg(src1) console.log(result1)}load() 关于 Generator 原理比较复杂 不是异步的直接代替方式 有更好简洁的的解决方案 aysnc/await koa 也放弃了Generator去使用 aysnc/await 123456789101112131415161718192021222324252627function* gen () { yield asyncLog(1); yield asyncLog(2); yield asyncLog(3); yield asyncLog(4); // return true;}function asyncLog (num) { setTimeout(() =&gt; { console.log(`这是第${num}次的调用`); }, 2000); return num;}function* f1 () { for(let i =0;i;i++){ var reset = yield i; if(reset) { i =-1; console.log(&quot;true&quot;); }; }}var g1 = f1()","link":"/2020/01/07/js%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5/"},{"title":"算法学习-动态规划的题目","text":"动态规划 递归 + 记忆化 —&gt; 递推 状态的定义： opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of( opt[n-1],opt[n-2], …. ) 最优子结构 最重要的两点 DP状态的定义 列出DP方程 001 - 爬楼梯（Leecode-70）假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 可以分析得到，每一层的方法数可以看做前一层和前第二层的方法加起来，因为前面一层一步上去，前面第二层两步上去。由此可以发现这个问题就可以转换成斐波那契问题来求解。 本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和 爬上 n-1n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶 爬上 n-2n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶 所以我们得到公式 dp[n] = dp[n-1] + dp[n-2]同时需要初始化 dp[0]=1 和 dp[1]=1时间复杂度：O(n) 代码实现： 12345678var climbStairs = function(n) { let arr = [1,2]; if(n&lt;=2) return n; for(let i = 2; i&lt;n; i++) { arr[i] = arr[i-1] + arr[i-2]; } return arr[n-1];} 002 - 三角形最小路径和 （Leecode-120）题目描述： 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 *+ *3 + 5 *+ *1 = 11）。 思路一 直接用贪心算法从第一个开始，每次都取下一层相邻两个当中最小的那个，这样看了似乎每次都能取到最小的。但是很明显会存在该层虽然不是最小的，但是他之后会有更小的路径之和。就算你取到了这一层最小的，极端点来项，加入后面全是几万大小的。显而易见局部最优普并不能一直最优。人生也是如此，当前做出的决定可能是最费时间，最辛苦的，但是后面的路怎么样谁都说不定。 思路二 动态规划但是如果我们可以自顶而上往最前面推，依次遍历每层，当前路径等于当前值加上相邻前面两个路径的最小值，一直到最后，这样我们就可以做出最好的选择。可是人生的选择不可以从后往前来。 定义： dp[i, j] :从下往上 方程： dp[j] = triangle[i][j] + Math.min(dp[j], dp[j+1]) 代码实现12345678910111213141516/** * @param {number[][]} triangle * @return {number} */var minimumTotal = function(triangle) { //使用动态规划，从下到上求解 var dp = [] for(let i = triangle.length - 1; i&gt;=0; i--) { for(let j = 0; j&lt;triangle[i].length; j++) { var min = Math.min(dp[j], dp[j+1]); dp[j] = triangle[i][j] + (min ? min : 0) } } return dp[0];};","link":"/2020/02/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E9%A2%98%E7%9B%AE/"},{"title":"算法学习三月份-第一节","text":"前段时间一直在做一个项目，好久没有刷算法题目了，现在三月份继续开始学习算法，算法可不能忽略，这是一个程序员的基本功。 调整数组顺序让奇数项位于偶数项之前输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 这个题目我第一个思路是： 首先判断奇偶用位运算 num &amp; 1 ，通过二进制可以明显的看到，奇数 &amp; 1得到的是1，偶数是0. 然后就是怎么循环，和需要开辟空间了 1. reduce函数1234567var exchange = function (nums) { var res = nums.reduce((pre, next) =&gt; { next &amp; 1 === 1 ? pre.unshift(next) : pre.push(next); //记得要return pre作为下一次pre的结果 return pre; }, [])} 但是不知道为何这样的方法挺费时的，用了两百多ms，我怀疑是 unshift 操作比较费时，因为 使用 unshift 是把一个新元素添加到数组头部，后面的元素都会依次往后推。 2. 直接循环，创建两个数组上面的方式费时的原因初步判断是 unshift 操作的原因，也可以直接创建两个数组， 是偶数就放进偶数的数组 12345678910var exchange = function (nums) { var odd = [], even = []; function isOdd (num) { return num &amp; 1; } for(let i = 0; i &lt; nums.length; i++) { isOdd(nums[i]) ? even.push(nums[i]) : odd.push(nums[i]); } return odd.concat(even);} 3.使用两个指针，从头到尾出发使用 start end 两个指针，如果前面的是偶数后面的是奇数就交换两者的值，不然继续走，当然还有一些临界条件需要判断的。 代码实现： 123456789101112131415161718var exchange = function (nums) { function isOdd (num) { return num &amp; 1; } var length = nums.length, start = 0, end = length - 1; while(start &lt; end) { //判断全是奇数或者偶数的时候 while(start &lt; length &amp;&amp; isOdd(nums[start])) start++; while(end &gt;= 0 &amp;&amp; !isOdd(nums[end])) end--; if(end &gt; start) { //交换两个的值，并且记得指针往前走 [nums[start], nums[end]] = [nums[end], nums[start]] start++; end--; } }} 字符串的排列输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 12输入：s = \"abc\"输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 思路一：直接依次遍历求结果，最后再用Set去重因为可能结果会用重复的值，最后返回结果的时候需要我们进行去重。 代码实现： 1234567891011121314151617181920212223242526272829303132333435/** * @param {string} s * @return {string[]} */var permutation = function (s) { var strs = s.split(''); var res = []; _permutation(strs, 0, res); return Array.from(nwe Set(res));} /*** @param {string[]} strs* @param {number} start* @param {string[]} res*/var _permutation = function (strs, start, res) { //在这里已经遍历到最后一个，返回结果 if(start === strs.length) { res.push(strs.join('')); return; } for(let i = start; i &lt; strs.length; i++) { //交换数组第i项和起始项的值，从start开始的原因是因为有默认不交换的 [strs[i], strs[start]] = [strs[start], strs[i]]; _permutaion(strs, start+1, res); //恢复到交换前 [strs[i], strs[start]] = [strs[start], strs[i]]; } } 在遍历的时候就通过一个map来去重，减少时间开销在遍历的时候就做了剪枝判断，减少了不必要的循环 12345678910111213141516171819202122232425262728var permutation = function (s) { var strs = s.split('') var res = [] _permutation (strs, 0, res); return res;}var _permutation = function (strs, start, res) { if(start === strs.length) { res.push(strs.join('')); return } //用于剪枝 let map = {}; for(let i = start; i &lt; strs.length; i++ ) { if(map[strs[i]]) continue; map[strs[i]] = true; [strs[i], strs[start]] = [strs[start], strs[i]] _permutation(strs, start+1, res); [strs[i], strs[start]] = [strs[start], strs[i]] } } 删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 实例： 123输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 思路：直接遍历然后比较这个方法就是暴力求解，不多说直接写代码 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @param {number} val * @return {ListNode} */var deleteNode = function(head, val) { if(head.val == val) return head.next; let p = head.next; let pre = head; while(p) { if(p.val === val) { pre.next = p.next; return pre; } pre = p; p = p.next; }} 删除排序数组中的重复项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素 由于是原地修改，意味着不能使用额外的空间， 而且原地修改后数组的长度也会发生变化，导致我直接用下面的方法会得不出正确答案 123456789var removeDuplicates = function(nums) { nums.forEach((item, index) =&gt; { if(nums.indexOf(item) !== index) { //这里修改了数组的长度，导致下一次循环会跳过原本的下一个索引 nums.splice(index, 1); } }) return nums.length}; 一开始还以为就是一个简单的数组去重，现在看来还是有点难度的，得继续往下思考； 由于这个是排序好了的数组，所以我们每次把一个有重复的项目删除第一个之后的，利用 lastIndexOf（） 代码实现： 12345678var removeDuplicates = function (nums) { for(let i = 0; i &lt; nums.length; i++) { var item = nums[i]; var lastIdx = nums.lastIndexOf(item); if(lastIdx !== i) nums.splice(i+1, lastIdx - i); } return nums.length;} 但是这种方法虽然 AC了，不过耗时非常久，初步原因是因为在循环中还利用了 lastIndexOf 方法去查询，时间复杂度还是挺高的。得试试不用再次查询的方法。 下面这种方法直接遍历， 再和下一个比较，如果相等就去除123456789var removeDuplicates = function (nums) { for(let i = 0; i &lt; nums.length; i++) { if(nums[i+1] == nums[i]) { nums.splice(i+1, 1); i--; } } return nums.length;} 这种方法其实也挺费时的，上面的那种方法也有自己的优点，如果重复的个数十分多，利用一次 判断索引就可以达到去重这个值，个人觉得还是用 lastIndexOf 的方法比较合适些。","link":"/2020/03/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%89%E6%9C%88%E4%BB%BD-%E7%AC%AC%E4%B8%80%E8%8A%82/"},{"title":"编译原理学习-第一节","text":"首先带着以下问题进行学习 1、 翻译程序与解释程序之间根本区别是什么？2、 翻译程序与解释程序各自优势？3、 编译程序与翻译程序之间的关系？4、 词法分析中，“单词”的理解？具体包括哪几类？5、 语法分析中，“语法单位/短语”的理解？具体包括哪些？6、 语法分析中，引入“语法树”这个工具，有什么好处？7、 语义法分析中，“静态语义”与“动态语义”的运行阶段？8、 为什么引入“中间代码”？9、 代码优化从效率角度讲，应考虑哪几个要素？10、“绝对地址的机器指令代码”与“可重定位的指令代码”的理解。 判断题1、编译程序是指将高级语言转化为机器语言的翻译程序。（ ）2、编译程序属于系统软件。（ ）3、在编译程序的设计中，代码优化是必须的。（ ）4、在源代码的编译程序处理过程中，数组越界属于语义错误。（ ）5、C语言的编译器可以用C语言来编写。（ ） 本课程的特点、难点和目的 特点 抽象难懂 算法多且算法复杂，不同于数据结构中的算法 难点 形式语言基本理论 自动机基本理论 语义分析（重点） 目的 训练抽象思维和形式化描述问题的能力 加深对程序设计语言本质的理解 了解一个变异程序的构造原理和方法 计算机中的软件可以主要分为两类 系统软件（操作系统软件，对性能和准确率要求非常高） 应用软件 绪论编译原理指的是编译程序的构造原理和技术 计算机语言的分类 低级语言 机器语言（唯一能被计算机执行的语言） 汇编语言 高级语言 C、C++ Java 等等 ​ 我们用户用的都是高级设计语言，如果直接交给计算机执行的话肯定是不能够被计算机执行的，所以我们需要把高级语言程序或者汇编语言程序转换成计算机可以识别的机器语言。 转化的方法就是 翻译或者解释 翻译程序 它能够把某一种语言程序（称为源语言程序）转化成另一种语言程序（称为目标语言程序），而后者与前者在逻辑上是等价的 编译程序​ 在翻译程序的基础之上， 如果源语言程序是一种 C++ Java 之类的高级语言，而目标语言是汇编语言或者机器语言之类的低级语言，那么这样的一个翻译程序就可以叫做 编译程序 ​ 而汇编程序 是用于特定计算机上的汇编语言的翻译程序 对编译程序的分类 交叉编译程序 源程序的编译和目标程序的执行不一定在同一种计算机上(比如在windows系统编译的程序要在 Linux系统上运行，甚至是Android系统)。当源程序由另外一种计算机的编译程序进行编译是，我们将此程序成为交叉编译程序。需要注意的是两个计算机是不是同一个操作系统，如果两个机器是同一个操作系统则不算是交叉编译程序。 诊断编译程序 专门用于帮助程序开发和调试程序的编译程序 优化编译程序 着重提高目标代码效率的编译程序 解释程序定义： 把源程序作为一种输入，而且不会产生目标程序，而是边解释边执行源程序的本身。 与编译程序的主要区别是： 会不会产生目标程序。 编译过程的概述编译程序的组成举个例子：比如将一段英文翻译成中文，我们会经过一下一些步骤 识别句子中的一个个单词 =》 词法分析 分析一个句子的语法结构 =》语法分析 分析句子的含义 =》 语义分析 进行初步翻译： =》 中间代码生成 对译文进行修饰 =》 中间代码优化 写出最后的译文 =》 目标程序生成 1. 词法分析程序（扫描器） 任务 输入源程序，对构成源程序的字符串（从左到右）进行扫描和分解，识别出一个一个的基本语法单位（也称为单词符号或语法符号） 删除无用的空白字符串、回车符以及其他与输入介质相关的非实质性字符 删除注释。 进行词法检查，报告所发现的错误 比如： For i:=1 To 100 Do 进行词法分析后 保留字： Foo 标识符： i 赋值符： := 整常数: 1 保留字: To 整常数: 100 保留字: Do 单词符号的表示和分类 表示：二元组（Class， Value），类别和组 分类：关键字（保留字），标识符， 数字、运算符、界符 词法分析阶段的工作依循的是语言的词法规则（即构词规则）。描述词法规则的有效工具是正规式和有限自动机。它是一种线性分析。 2. 语法分析程序 任务 在词法分析的基础之上，根据语言的语法规则 分析方法 完成这种分析，一般的途径是由语法分析程序试着为其构造一颗完整的语法树，如果构造失败说明有语法错误，最终的根节点就是一个程序。 描述方法： 在语法分析阶段的工作中依循的是语言的语法规则。描述语法规则的有效工具是 上下文无关文法（二型文法）。 它是一种层次结构分析。 3. 语义分析程序 任务： 对语法分析程序所识别出的各类语法成分，分析其含义，以保证源程序在语义上的正确性。 语义的分类 静态语义：指在编译阶段就能检查出的语义。典型静态语义包括声明和类型检查 动态语义： 只有目标代码的运行阶段才能检察出的语义。 4.中间代码生成 任务： 按语言的语义规则把各类语法范畴翻译成中间语言代码。（比如把 翻译成三元表达式） 中间代码的定义： 所谓的 中间代码 是一种含义明确、便于处理的记号系统，是位于源代码和目标代码之间的代码形式，它独立于具体的硬件。这种记号系统比较容易转化成现代计算机的机器指令。简单的说，中间代码是一种独立于具体硬件的记号系统。 中间代码的形式 四元式，三元式，间接三元式，逆波兰式等。 5. 代码优化程序 任务 对前段产生的中间代码进行加工变化，以期在最后阶段能产生更为高效（时间和空间）的目标代码。 分类 优化分为局部优化（循环优化）和全局优化 优化所遵循的规则 程序的等价变化原则（当然不可能优化完程序不一样了） 例1： 123456789a[index] := 4+2中间代码：t = 4+2 a[index] = t(t是一个临时变量) 优化： t = 6 a[index] = t 优化： a[index] = 6 6. 目标代码生成程序 任务 把中间代码（或者经过优化处理过的）变成特定机器上的低级语言代码（汇编语言或者机器语言） 它依赖具体的计算机硬件系统结构和指令系统 要求 对于所用的翻译策略或算法要做到： 使所生成的目标代码尽可能短 充分利用计算机可用资源效率 目标代码的的形式 绝对地址的机器代码指令 这种代码可以立即执行 汇编语言形式的目标程序 这种代码还需要汇编程序汇编之后才能运行 模块结构的机器指令（可重定位的指令代码） 这种代码在运行前必须借助于一个链接装配程序把各个目标模块连接在一起，装入内存中，使之成为一个可以运行的绝对地址的机器指令代码程序 7. 错误检查和处理程序 错误的种类 语法错误（不符合语法或词法规则，可以在词法分析或者语法分析的时检测出来） 语义错误（不符合语义规则，有些能在语义分析阶段检测，有些需要在运行时才能检测出来） 8.信息表管理程序 最重要的是符号表 信息表的结构 编译程序的组织1.遍 定义 是对源程序或是源程序的中间结果从头到位扫描一次，并做有关的加工程序，生成新的中间代码或者目标程序。 一遍 或者多遍 2. 前端和后端源代码 –&gt; 前端 –&gt; 中间代码 –&gt; 后端 –&gt; 目标代码 前端 主要与源程序有关但与目标机（运行编译程序的计算机称宿主机，运行编译程序锁产生的目标代码的计算机称目标机）无关。 后端 包括编译程序中与目标机有关的那些部分 优点： 取编译程序的前端，改写其后端以生成不同目标机上的相同语言的编译程序。 编译程序的生成 编译程序的设计目标 目标程序小，执行速度快 编译程序小，执行速度快 诊断能力强，可靠性高 可移植性好，可扩充性 编译程序的生成 合理的方法是使用另外一种语言来编写编译器，而使用该种语言的编译器早已经存在 ​","link":"/2020/03/09/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E8%8A%82/"},{"title":"算法数据结构学习-栈和队列","text":"1. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses 示例 1: 12输入: &quot;()&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 利用栈的性质，出现左括号就把左括号放进栈中，出现右括号并且在栈中的第一个左括号与之相匹配就弹出，循环上述步骤，直到栈中所有数据弹出，返回 true 代码实现： 123456789101112131415161718192021/** * @param {string} s * @return {boolean} */var isValid = function(s) { var stack = [], right = {')':'(', ']','[', '}':'{'}; for(let i = 0; i &lt; s.length; i++) { let item = s[i]; if(item in right) { if(right[item] === stack[stack.length - 1]) { stack.pop() } else { return false; } } else { stack.push(item); } } return !s.length;} 二叉树的层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7] 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 思路： 层次遍历每一层，将每一层从左到右push 到一个队列中然后再 shift 到这一层对应的数组当中，直到遍历完所有的，开用的是栈和队列这两个数据结构的特性 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { if(!root) return []; var res = [], level = 0,queue = []; queue.push(root); while(queue.length) { res[level] = []; let size = queue.length while(size--) { let item = queue.shift(); res[level].push(item); if(item.left) queue.push(item.left); if(item.right) queue.push(item.right); } level++; } return res; }","link":"/2020/03/08/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"title":"cookies session token 的作用和区别","text":"session 、cookie、token的区别及联系什么是session session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 what is cookie cookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 ​ cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”&quot;)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。下面是一个简单的js使用cookie的例子: 用户登录时产生cookie: 12345document.cookie = &quot;id=&quot;+result.data['id']+&quot;; path=/&quot;;document.cookie = &quot;name=&quot;+result.data['name']+&quot;; path=/&quot;;document.cookie = &quot;avatar=&quot;+result.data['avatar']+&quot;; path=/&quot;; 使用到cookie时做如下解析： 1234567891011var cookie = document.cookie;var cookieArr = cookie.split(&quot;;&quot;);var user_info = {};for(var i = 0; i &lt; cookieArr.length; i++) { user_info[cookieArr[i].split(&quot;=&quot;)[0]] = cookieArr[i].split(&quot;=&quot;)[1];}$('#user_name').text(user_info[' name']);$('#user_avatar').attr(&quot;src&quot;, user_info[' avatar']);$('#user_id').val(user_info[' id']); Why token​ token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库 cookie 和session的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 token 和session 的区别​ session 和 oauth token并不矛盾，作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态 ​ App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。 如果你的后端不是stateless的rest api, 那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session. Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。这里的 Token是唯一的。不可以转移到其它 App上，也不可以转到其它 用户 上。 转过来说Session 。Session只提供一种简单的认证，即有此 SID，即认为有此 User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。 所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。 token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。 分别对Cookie与Session做一个介绍和总结，进行对比分析 cookie机制​ Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。 ​ 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。​ cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。​ 而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。​ session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。​ 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。 session机制session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。 存取方式的不同 ​ Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。 隐私策略的不同 ​ Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。​ 假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。 有效期上的不同 ​ 使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。​ 由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。 服务器压力的不同 ​ Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。​ 而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。 浏览器支持的不同 ​ Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。​ 假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。​ 假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干） 跨域支持上的不同 ​ Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。 ​ 仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。 关系的理解客户第一次发送请求给服务器，此时服务器产生一个唯一的sessionID，并返回给客户端(通过cookie)，保存于客户端的内存中，并与一个浏览器窗口对应着,由于HTTP协议的特性，这一次连接就断开了 以后此客户端再发送请求给服务器的时候，就会在请求request中携带cookie,由于cookie中有sessionID,所以服务器就知道这是刚才那个客户端。 举个简单例子就像人们去超市购物，去存包，第一个去的时候(客户第一次发送请求给服务器),超市会给你一个号码牌(此时服务器产生一个唯一的sessionID，并返回给客户端(通过cookie)),你可以在你自己的柜子里存东西(在服务器属于此客户的内存区域存数据),下次你再去的时候，拿着这个号码牌(请求request中携带cookie),超市就知道哪些东西是你的，然后给你取出来，如果你几天都没去取（session失效了，在服务器端配置）,你再去的时候东西就拿不到了如果你把这个号码牌丢了(刚才的cookie失效了，比如你重启电脑，刚才存于内存中sessionID也就丢了)，再去拿东西，当然无法定位了，也就拿不到东西了如果是新打开一个浏览器的情况，那就像是又一个人去超市存东西一样，你的东西跟他的东西是两码事，互不影响,他有他自己的sessionID,你有你自己的","link":"/2019/12/24/cookies-session-toke/"},{"title":"git常见指令","text":"git 年末大总结 原文链接：掘金 GitGit是目前世界上最先进的分布式版本控制系统。 1. 版本控制所谓版本控制就是在文件的修改历程中保留修改历史，让你可以方便地查询历史提交记录以及撤销之前对文件的修改操作。版本控制系统主要有集中式版本控制系统和分布式版本控制系统两种。 1.1 集中式版本控制系统集中式版本控制系统，版本库是集中存放在中央服务器的，工作时需要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。 1.2 分布式版本控制系统分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 2. Git理论基础学习git首先需要了解其中涉及到的四个重要概念： 远程仓库(Remote Directory) 工作目录（Working Directory） 暂存区(Stage/Index) 版本库(Repository或Git Directory) 对于以上四个概念，我们依次理解。 2.1 远程仓库(Remote Directory)远程仓库(Remote Directory)就是我们在远程服务器上面创建的一个仓库，通常这个仓库存储我们的代码，我们拿GitHub来做个demo，我们在GitHub上面创建一个远程仓库awesome-git，这个仓库空空如也，刚创建的，等会我们便拿这个仓库进行学习git的相关操作。后面我们需要对这个仓库进行操作，如pull，push，branch，tag，reset等等命令，这些命令后面会详细了解。 2.2 工作目录（Working Directory）在上个小节，我们创建了一个远程仓库awesome-git，我们需要将它先放到本地进行相关操作，如存放在本地电脑awesome-git目录下，这个本地文件夹awesome-git就是我们的工作目录，这个就是我们平时存放项目代码的地方。 2.3 暂存区(Stage/Index)我们在上个小节中工作目录下面会看见一个.git的文件夹，其实这是一个隐藏的文件夹，这个文件夹是Git的版本库，他是存放Git管理信息的目录，初始化仓库的时候自动创建。暂存区英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。其次，Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 2.4 版本库(Repository或Git Directory)工作目录中有一个隐藏目录.git，这个就是Git的版本库。 3. Git工作流程我们用一张图来表示这四个区域之间的联系： 上面的这张图就是整个git的工作流程，整体如下： 我们将文件存放到工作目录中，譬如我们新建的代码文件 用git add把工作目录中的文件添加到暂存区，此时暂存区的目录树被更新 用git commit提交就是把暂存区的所有内容提交到当前分支，如当前分支是master上面，此时master 分支会做相应的更新。 经过以上三个步骤的操作，此时工作目录中的文件状态会经历三种过程：已修改（modified）=&gt; 已暂存（staged）=&gt; 已提交(committed) 3.1 实战练习上面一系列操作文件的状态会发生变化，我们来实际学习一下，上面我们创建的awesome-git这个仓库之后会生成一个README.md这个文件，打开看一下里面内容：里面只有一行“# awesome-git” 我们在这个文件里面添加一行注释 “深入理解git” 变成下面： 此时我们更改了文件，我们通过一个命令 git status 来查看此时的文件状态： git add git commit 此刻我们经过一系列的操作，已经提交到master分支上了，同时工作区里面没有改动了： 经过一系列上述的操作，此刻文件已经放到了master分支上，接下来我们需要将这个文件push到远程仓库中去， git push 此刻已经推送到了远程仓库中去了。这是最简单git操作了，下面我们将在第7小节中讨论其他一系列复杂的操作。 4. Git分支管理我们开发项目一般都是进行在分支上面开发的，而不是直接在master分支，当开发完成之后我们再将在其他分支上面的代码合并到master分支。接下来我们将详细学习分支的常用操作。我们每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 4.1 新建分支我们通过以下命令来创建一个分支： 4.1.1 创建分支123//新建dev分支git branch dev复制代码 4.1.2 查看所有分支通过以上命令即可创建一个新分支dev，我们查看以下目前这个repo包含哪些branch 123//查看分支git branch 复制代码 4.2 切换分支可以看到目前存在两个分支，dev和master分支，master分支前面有个*号表示当前分支是在master上面。我们可以通过下面命令来切换分支： 123//切换到dev分支git checkout dev复制代码 4.3 合并分支上面我们已经创建了新分支dev，假设我们在新分支上面开发了一些内容譬如新建一个文件dev.md，我们把这个文件提交到dev分支，通过以下命令即可完成： 123456//将dev.md这个文件添加到stagegit add dev.md//将dev.md这个文件提交到dev分支git commit -m &quot;add new file to branch dev&quot;复制代码 ![在这里插入图片描述](data:image/svg+xml;utf8,) 1.首先要切回到master分支 2.合并dev分支 123//合并语法git merge 分支名复制代码 冲突 3.解决冲突 首先，我们切回到dev分支，然后在dev.md这个文件中将里面的内容替换一下： 替换成： 现在尝试合并dev分支就会出现冲突： Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们只需要确认哪些部分是需要的，删除不需要的部分即可。最后再冲洗提交到master分支。 我们可以通过下面的命令查看分支合并情况： 12git log --graph --pretty=oneline --abbrev-commit复制代码 4.4 删除分支在dev分支上面开发好了之后把代码合并到master分支上面，这个dev分支就不需要了，我们将它删除并查看一下分支情况，可以发现只有一个master分支了： ![在这里插入图片描述](data:image/svg+xml;utf8,) 5. Git标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。 tag 和 branch 有点相似，两者有何区别呢？tag 对应某次 commit, 是一个点，是不可移动的，branch 对应一系列 commit，是很多点连成的一根线，有一个HEAD 指针，是可以依靠 HEAD 指针移动的。所以，两者的区别决定了使用方式，改动代码用 branch ,不改动只查看用 tag。 tag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如 已经发布了 v1.0 v2.0 v3.0 三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0 的基础上加个新功能，作为 v4.0 发布。就可以 检出 v2.0 的代码作为一个 branch ，然后作为开发分支。 5.1 新建tag123// 新建tag语法git tag &lt;tag名&gt;复制代码 5.2 查看tag注意: 标签不是按时间顺序列出，而是按字母排序的。可以用以下语法进行查看标签信息 123// 查看tag语法git tag 复制代码 5.3 删除tag要删除掉你本地仓库上的标签，可以使用如下命令： 123//删除tag语法 git tag -d &lt;tag名&gt;复制代码 通过以上命令我们删除v1.0的tag 然后再查看以下tag，发现只剩下v2.0的tag了。 6. Git远程操作GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。 在GitHub上面新建一个test的repo，可以进行以下的命令操作，即可以将本地的东西提交到GitHub上面的test仓库中： 12345678910111213141516//新建一个readme.md文件echo &quot;# test&quot; &gt;&gt; README.md//初始化本地仓库git init//将readme.md这个文件加入到stage中去git add README.md//将readme.md这个文件放到master分支上去git commit -m &quot;first commit&quot;git remote add origin https://github.com/crazyandcoder/test.git//将这个推送到远程的master分支上去git push -u origin master复制代码","link":"/2019/12/26/git%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"},{"title":"vue-vuex上手","text":"简单解释Vuex 使用 单一状态树,通俗理解就是一个应用的数据集合，可以想象为一个“前端数据库”，让其在各个页面上实现数据的共享，并且可操作 Vuex分成四个部分： State：单一状态树 Getters：状态获取 Mutations：触发同步事件 Actions：提交mutation，可以包含异步操作 正如上图所示，Vuex的数据总是“单向流动” 用户访问页面并触发action action提交mutation事件 mutation事件更改state状态 state状态改变后更新页面(vue comptents) Vuex 规定，属于应用层级的状态只能通过 Mutation 中的方法来修改，而派发 Mutation 中的事件只能通过 action。 用法从左到右，从组件出发，组件中调用 action，在 action 这一层级我们可以和后台数据交互，比如获取初始化的数据源，或者中间数据的过滤等。然后在 action 中去派发 Mutation。Mutation 去触发状态的改变，状态的改变，将触发视图的更新。 注意事项 数据流都是单向的 组件能够调用 action action 用来派发 Mutation 只有 mutation 可以改变状态 store 是响应式的，无论 state 什么时候更新，组件都将同步更新 State在 store 中的 state 对象，可以理解为 Vue 实例中的 data 对象，它用来保存最基本的数据。 声明1234567891011121314import Vue from 'Vue';import Vuex from 'Vuex';Vue.use(Vuex);let store = new Vuex.Store({ state: { stateA: 'a', stateB: 'b', stateC: 'c' }});console.log(store.state.stateA); // a 在 Vue 中获取 store 中的状态 123456789let app = new Vue({ el: '#demo', template: '&lt;h1&gt;{{myState}}&lt;/h1&gt;', computed: { myState() { return store.state.stateA; } }}); 最简单的方式就是通过 Vue 中的计算属性(computed) 来将 store 中的状态映射为 Vue 的数据。但是当数据多时这种方法明显效率过低，所以 Vuex 中提供了 mapState 方法用于批量映射 store 中的状态。 mapState映射12345678910111213141516import { mapState } from 'Vuex';let app = new Vue({ el: '#demo', store, data: { local: 'L' }, computed: mapState({ stateA: state =&gt; state.stateA, stateB: 'stateB', stateC(state) { return state.stateC + this.local; } })}); 上例中，a. 可以通过 ES6 中的箭头函数进行数据的映射，b. 当计算属性的名称与 state 的属性名一致时可能直接通过字符串赋值，c. 当需要引用上下文中的 data 属性实，只能通过常规函数来使 this 生效。 如果所有计算属性的名称都与 state 一致，可以在 mapState 中以数组的方式进行映射。如果 Vue 中已经存在计算属性，可以通过 ES6 的对象展开运算符 (…) 进行组合。 12345678910let app = new Vue({ el: '#demo', store, computed: { local() { return 'Local'; }, ...mapState(['stateA', 'stateB', 'stateC']) }}); 在 Vuex 模块化中，state 是唯一会根据组合时模块的别名来添加层级的，后面的 getters、mutations 以及 actions 都是直接合并在 store 下。 例如，访问模块 a 中的 state，要通过 store.state.a，访问根 store 上申明的 state，依然是通过 store.state.xxx 直接访问。 Mutations在vuex中，更改state 的方式只有提交mutation.大家可以把他就想象成vue中methods 中的一个方法。 1234567891011121314let store = new Vuex.Store({ state: { count: 0 }, mutations: { addCount(state) { state.count ++; } }});store.commit('addCount');console.log(store.state.count); // 1 想要改变状态的时候都是用store.commit的方式 传参方式 每一个 mutation 都有一个字符串的事件类型和一个回调函数,每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 第一种方式：提交载荷（Payload） 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： 12345678...mutations: { addCount(state, n) { state.count += n; }}store.commit('addCount', 10); 官方推荐，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： 123456789// ...mutations: { increment (state, payload) { state.count += payload.amount }}store.commit('increment', { amount: 10}) 第二种方式：对象风格的传参方式 提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit({ type: 'increment', // 事件名 amount: 10}) Mutations 需遵守 Vue 的响应规则在 mutation 中更改 state 应该以新对象替换老对象，不要在直接原对象上直接修改。 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, ‘newProp’, 123),或者 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： 1state.obj = { ...state.obj, newProp: 123 } mutation 必须是同步函数1234567mutations: { someMutation (state) { api.callAsyncMethod(() =&gt; { state.count++ }) }} 在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用 —— 实质上任何在回调函数中进行的的状态的改变都是不可追踪的。 在组件中提交 Mutations你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。 12345678910111213import { mapMutations } from 'vuex'export default { // ... methods: { ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), ...mapMutations({ add: 'increment' // 映射 this.add() 为 this.$store.commit('increment') }) }} 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务： 12store.commit('increment')// 任何由 &quot;increment&quot; 导致的状态变更都应该在此刻完成。 Actions与 mutations 类似，不同模块的 actions 均可以通过 store.dispatch 直接触发。 1234567891011121314151617181920212223242526272829303132333435363738394041const moduleA = { state: { count: 1 }, mutations: { sayCountA(state) { console.log('Module A count: ', state.count); } }, actions: { maAction(context) { context.dispatch('mbAction'); } }};const moduleB = { state: { count: 2 }, mutations: { sayCountB(state, num) { console.log('Module B count: ', state.count+num); } }, action: { mbAction({ commit, rootState }) { commit('sayCountA'); commit('sayCountB', rootState.a.count); } }};const store = { modules: { a: moduleA, b: moduleB }};store.dispatch('maAction'); // Module A count: 1、Module B count: 3 action 的回调函数接收一个 context 上下文参数，context 包含：1. state、2. rootState、3. getters、4. mutations、5. actions 五个属性， 有一点要注意的是，将 store 中的 state 绑定到 Vue 组件中的 computed 计算属性后，对 state 进行更改需要通过 mutation 或者 action，在 Vue 组件中直接进行赋值 (this.myState = ‘ABC’) 是不会生效的。 Getters这个属性有点类似过滤器的作用，只不过它是新增的，有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 12345computed: { doneTodosCount () { return this.$store.state.todos.filter(todo =&gt; todo.done).length }} 什么时候使用？当需要对 store 中的数据进行处理，或者需要对处理后的数据在多个组件进行复用，就可以使用 Getters 来处理，Getters 也可以理解为 Vue 中的计算属性 (computed)。 vuex 允许我们在 store 中定义『getters』（可以认为是 store 的计算属性）。Getters 接受 state 作为其第一个参数： 1234567891011let store = new Vuex.Store({ state: { nowDate: new Date() }, getters: { dateFormat(state, getters) { let date = state.nowDate; return `${date.getFullYear()}-${date.getMonth()+1}-${date.getDate()} / ${date.getHours()}:${date.getMinutes()}`; } }}); Getters 会暴露为 store.getters 对象： 1console.log('The time is now:', store.getters.dateFormat); // The time is now: 2017-2-10 / 17:28 Getters 也可以接受其他 getters 作为第二个参数： 1234567getters: { // ... doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length }}store.getters.doneTodosCount // -&gt; 1 我们可以很容易地在任何组件中使用它： 12345computed: { doneTodosCount () { return this.$store.getters.doneTodosCount }} mapGetters 辅助函数mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，类似于mapState： 12345678910111213import { mapGetters } from 'vuex'export default { // ... computed: { // 使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) }} 如果你想将一个 getter 属性另取一个名字，使用对象形式： 1234mapGetters({ // 映射 this.doneCount 为 store.getters.doneTodosCount doneCount: 'doneTodosCount'}) 命名空间为了解决getters、mutations 以及 actions 都是直接合并在 store 下，所以就需要开发者一定要注意types命名 12345678910/** * mulations 常量，根据页面组件来分组 * 命名方式：[MODULE]/[ACTION]_[CONTAINER]_[FUNCTION]_[COMPONENT]_[STATE] * MODULE: 模块名[deposit] * ACTION: 行为[change, set, add...] * CONTAINER: 组件所在的父级容器或者所在页面 * FUNCTION: 组件表示的业务功能名 * COMPONENT: 组件[input, dropdown...] * STATE: 组件状态, 单一状态[open, close, show...] */","link":"/2019/12/27/vue-vuex-%E4%B8%8A%E6%89%8B/"},{"title":"virtual dom（虚拟DOM）","text":"virtual dom（虚拟DOM） vdom是vue和React的核心，先讲哪个都绕不开它 vdom比较独立，使用也比较简单 如果面试问到vue和React的实现，vdom是肯定会问的 关于vdom的几个问题 vdom是什么？为什么会存在vdom？jQuery它不香吗？ vdom如何使用，核心API是什么？ 介绍一下 diff算法 1. 什么是vdom，为何使用vdom,如何用JS模拟DOM结构 virtual dom 虚拟DOM 用JS模拟DOM结构 DOM变化的对比，放在JS层来做（js是图灵完备语言） 提高重绘重排性能 1234567891011121314151617181920212223242526272829303132 &lt;ul id=&quot;list&quot;&gt; &lt;li class=&quot;item&quot; id=&quot;item1&quot;&gt;item 1&lt;/li&gt; &lt;li class=&quot;item&quot; id=&quot;item2&quot;&gt;item 2&lt;/li&gt; &lt;/ul&gt;//使用JS模拟DOM结构{ tag: 'ul', attrs: { id: 'list' }, children:[ { tag: 'li', attrs:{ className: 'item', id: 'item1' }, children: ['item 1'] }, { tag: 'li', attrs:{ className: 'item', id: 'item2' }, children: ['item 2'] } ]} 设计一个需求场景123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id=&quot;caontainer&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var data = [ { name: &quot;wang san&quot;, age: 20, address: &quot;北京&quot; }, { name: &quot;zhang san&quot;, age: 23, address: &quot;上海&quot; }, { name: &quot;wang si&quot;, age: 22, address: &quot;广州&quot; }, ] function render (data) { var container = $(&quot;#caontainer&quot;) container.html(&quot;&quot;); var $table = $('&lt;table&gt;') $table.append('&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;&lt;/tr&gt;') data.forEach(function (item) { $table.append('&lt;tr&gt;&lt;td&gt;item.name&lt;/td&gt;&lt;td&gt;item.age&lt;/td&gt;&lt;td&gt;item.address&lt;/td&gt;&lt;/tr&gt;') }) container.append($table) } $(&quot;#btn&quot;).click(function () { data[1].age = &quot;32&quot; data[2].address = &quot;南昌&quot; render(data) //每次都会重新渲染DOM节点 })&lt;/script&gt; 原因： DOM操作是”昂贵”的，JS运行效率是很高的 尽量减少DOM操作，而不是每次都“推到重来” 项目越复杂，影响就越严重 vdom就可以解决这个问题 2. vdom如何应用，核心API是什么什么是snabbdom1234567891011121314151617181920212223242526272829var snabbdom = require('snabbdom');var patch = snabbdom.init([ // Init patch function with chosen modulesrequire('snabbdom/modules/class').default, // makes it easy to toggle classesrequire('snabbdom/modules/props').default, // for setting properties on DOM elementsrequire('snabbdom/modules/style').default, // handles styling on elements with support for animationsrequire('snabbdom/modules/eventlisteners').default, // attaches event listeners]);var h = require('snabbdom/h').default; // helper function for creating vnodesvar container = document.getElementById('container');var vnode = h('div#container.two.classes', {on: {click: someFn}}, [h('span', {style: {fontWeight: 'bold'}}, 'This is bold'),' and this is just normal text',h('a', {props: {href: '/foo'}}, 'I\\'ll take you places!')]);// Patch into empty DOM element – this modifies the DOM as a side effectpatch(container, vnode);var newVnode = h('div#container.two.classes', {on: {click: anotherEventHandler}}, [h('span', {style: {fontWeight: 'normal', fontStyle: 'italic'}}, 'This is now italic type'),' and this is still just normal text',h('a', {props: {href: '/bar'}}, 'I\\'ll take you places!')]);// Second `patch` invocationpatch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state// to unmount from the DOM and clean up, simply pass nullpatch(newVnode, null) 尝试着使用一下snabbdom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var snabbdom = window.snabbdom //定义 patch var patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) //定义 h var h = snabbdom.h var container = document.getElementById(&quot;container&quot;) //生成 vnode var vnode = h('ul#list',{},[ h('li.item',{},&quot;item-1&quot;), h('li.item',{},&quot;item-2&quot;) ]) patch(container,vnode) console.log(patch.toString()); document.getElementById(&quot;btn&quot;).addEventListener('click', function (e) { var newVnode = h('ul#list',{},[ h('li.item',{},&quot;item-1&quot;), h('li.item',{},&quot;item-B&quot;), h('li.item',{},&quot;item-3&quot;) ]) patch(vnode,newVnode) //会重新比较 },false)&lt;/script&gt;&lt;/html&gt; snabbdom的实际应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-class.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-props.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-style.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom-eventlisteners.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/snabbdom/0.7.3/h.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var snabbdom = window.snabbdom //定义 patch var patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners ]) //定义 h var h = snabbdom.h var data = [ { name: &quot;wang san&quot;, age: 20, address: &quot;北京&quot; }, { name: &quot;zhang san&quot;, age: 23, address: &quot;上海&quot; }, { name: &quot;wang si&quot;, age: 22, address: &quot;广州&quot; }, ] data.unshift({ name: &quot;姓名&quot;, age: '年龄', address: '地址' }) var container = document.getElementById(&quot;container&quot;) //渲染函数 var vnode function render (data) { var newVnode = h('table',{},data.map((item) =&gt; { var tds = [] var i; for(i in item) { if(item.hasOwnProperty(i)){ tds.push(h('td', {}, item[i] + '')) } } return h('tr',{}, tds) })) if(vnode) { patch(vnode,newVnode) } else { //初次渲染 patch(container, newVnode) } vnode = newVnode } render(data) $(&quot;#btn&quot;).click(function () { console.log(vnode); data[1].age = &quot;30&quot; data[2].address = &quot;南昌&quot; render(data) })&lt;/script&gt;&lt;/html&gt; 3. 介绍一下 diff 算法 什么是 diff 算法 去繁就简 diff算法非常复杂，实现难度很大，源码量很大 去繁就简，讲明白核心流程，不关心细节 面试官也大部分都不清楚细节，但是关心核心流程 去繁就简之后还是很有挑战性，值得去研究 vdom 为什么要用diff算法 DOM 操作是昂贵的，因此要尽量减少DOM操作 找出本次DOM必须更新的节点来更新，其他的不更新 这个”找出”的过程，就需要diff算法 diff实现过程 patch(container,vnode) patch(vnode,newVnode) createElement updateChildren 12345678910111213141516171819202122232425&lt;script&gt; function createElements (vnode) { let tag = vnode.tag let attrs = vnode.attrs let children = vnode.children if(!tag) return null; //创建元素 let elem = document.createElement(tag) //添加属性 for(var attrName in attrs) { if(attrs.hasOwnProperty){ elem.setAttribute(attrName,attrs[attrName]) } } console.log(children); //给elem添加子元素,子元素递归生成 children.forEach(function (child) { elem.appendChild(createElements(child)) }) //返回真实的DOM节点 return elem; } document.body.append(createElements(vnode))&lt;/script&gt; 比较两个vdom之间的区别12345678910111213141516171819202122232425function updateChildren (vnode, newVnode) { let children = vnode.children || [] let newChildren = newVnode.children || [] //遍历现有的 children children.forEach( function (childVnode, index) { var newChildVnode = newChildren[index] if(childVnode.tag == newChildVnode.tag) { //深层次对比，递归 updateChildren(childVnode, newChildVnode) }else{ //替换 replaceNode(childVnode,newChildVnode) } }) }function replaceNode (vnode,newVnode) { let elem = vnode.elem let newElem = createElements(newVnode) //替换 .......} diff算法还包括 节点新增和删除 节点重新排序 节点属性、样式、时间绑定 如何极致压榨新能 ……….","link":"/2020/01/08/virtual-dom%EF%BC%88%E8%99%9A%E6%8B%9FDOM%EF%BC%89/"},{"title":"vue全家桶打造简易版QQ音乐webapp","text":"线上体验地址 二维码： ) 数据接口来自： github.com/Rain120/qq-… 项目git地址： ‘github.com/wangthing/v… 项目启动1234567891011121314151617181920# 下载项目$ git clone https://github.com/wangthing/vueMusicPlayer$ cd vueMusicPlayer# 下载项目依赖npm install# clone后台项目$ git clone https://github.com/Rain120/qq-music-api$ cd qq-music-api#下载后台接口需要的依赖$ npm install#返回根目录并启动项目$ cd ../#同时运行两个项目npm run start# 后台项目默认3200#也可以分开跑两个项目 后台项目 npm run start#前端项目 npm run dev复制代码 前言​ 其实很早之前就打算做一个有意思的项目练练手，不过之前的基础还是太差了，光 webpack配置和 vue组件化我都用的够呛， css布局也是胡乱用 。上个学期用 vue-cli 写的一个论坛社区也算很痛苦， 完全是为了应付课设，充分的体现了 能用不久行了嘛的思想，这次寒假认真的把基础补了一下，vue源码也尝试去阅读了一下，不过只能算是浅尝辄止，主要是去理解了 vue2如何实现响应式原理以及双向数据绑定，在把这些看完了之后再去使用vue还是别有一番新的体验的。就这样觉得自己算是稍微掌握了一些vue的知识 ，为了学以致用，就觉得开始做做个项目来试试这段时间的积累有没有大的提升。我自己也想尝试一下，现在的我到底能不能从0开始完成一个比较完整的项目。所以就开始这个项目，选择QQ音乐的原因一是我自己一直用的是QQ音乐，二是解决也有好几个大佬写过网易云音乐的了。 ​ 这次项目最大的体验还是明白了 vue 组件化带来的好处，当业务越来越大时，组件化的好处就逐渐体现出来了，代码的可服用复用，以及耦合度降低使得维护起来十分的方便，我也尝试着去封装了几个组件。sass对开发减少css代码编写， vuex 全局状态管理利用好使得组件之间的通信变得简单。 主要技术和工具介绍前端 vue.js 一款渐进式js框架 渐进式这个词形容vue真的很贴切 vue-router vue的官方路由管理器 vuex 一些全局状态管理 vue-lazyload 很好用的图片懒加载插件 axios 请求后台数据 vue-bus 做一些组件之间的消息传递和事件触发 sass 说来惭愧只用了一些基本的语法，不过真的很好用，可以减少大量css代码 flex布局 这就不多说了，移动端布局必备 ES6 使用了部分新特性 组件化开发，提高代码的复用性，便于维护 以及一些好用的ES6新特性 后台数据 html5 audio 实现音乐播放器 其他 后台是上面提到的 qq-music-api ，有了真实的数据干起来才有劲 iconfont阿里巴巴的官方图标库，真的很赞 vue-cli脚手架， 快速初始化一个 vue项目 vscode 编辑器，太占内存了，我就8g内存再加上谷歌浏览器十多个标签页，多难受就不多说了 项目部署在 阿里云服务器上，还是白嫖同学的。狗头 主要功能首页推荐（主要是热门歌单推荐）、 歌单详情页面、歌曲列表组件、分类歌单、 底部播放器组件、 播放列表组件、 歌词组件、排行榜页面、 排行榜详情、 歌手分类页面、 歌手详情页面、 搜索页面（热门搜索、历史搜索）、搜索结果展示、最近播放列表 主要难点和实现 播放歌曲点击定位按钮定位到当前列表正在播放的歌曲 通过锚点定位再加上css的 scrollbehavior： smooth 或者JS的 scrollIntoView（{behavior： &quot;smooth&quot;}） 也可以做到， 歌词页面点击歌词跳转到这句歌词的进度的实现也是如此，不过定位是会定到浏览器顶端， 可以通过添加一个子元素，隐藏子元素，通过定位子元素来达到把歌词定位到页面任意位置 点击歌词跳转主要要解决的是你在滑动歌词的时候阻止换歌词时页面滚动 歌词进度条变化，我是采取了比较暴力的 watch 监听当前播放时间从而改变宽度，当然要加上一个节流函数 由于显示歌词页面和播放列表是一个全局组件，通过 vuex 全局控制显示隐藏，当用户并没有点击左上角的隐藏按钮，而是直接用手机自带的返回或者浏览器的后退，会导致组件还显示，但是页面却回退了，甚至直接退出了。 我的解决办法是才用了 vue-router 的全局前置守卫， 当浏览器后退时候如果还是显示歌词页面的话会将歌词页面隐藏。 歌单和歌手详情的头部导航栏在下滑时会有标题和透明度的变化，也是通过节流监听滚动条的变化来改变，不过在一些浏览器比如微信和QQ内置的浏览器会失效，还没有找到原因 排行榜详情页面歌曲列表的接口返回的字段和其他页面的很不一样，甚至少了最关键的 vkey 字段，只能重复写了很多代码，歌曲列表组件在这个页面不能复用，解决办法就是先通过歌曲的专辑id查到专辑的歌曲列表，再返回这首的 mid 再去查询歌曲信息，绕了一个大弯很是头疼，导致后面的正在播放歌单列表增加了一大堆工作量。 有些付费的歌曲不能播放，后面看能不能从其他渠道找到播放源 搜索历史和播放历史用浏览器自带的 localStorage 来做存储，需要注意的是 localStorage 存储的是字符串，在进行读写的时候需要进行转化 搜索输入值改变时实时获取显示智能匹配，这个情景最算是双向数据绑定最经典的体现了 已经对一些请求存储在 vuex 做缓存优化， 对一些可能会常用的数据进行缓存可以减少请求，同时也是为了更好的用户体验。 在把项目放到 nginx 云服务器上时一开始还想着是不是 把项目开发环境直接放到服务器上 npm install然后 npm run dev,要不是看到网上说直接把 打包后的dist文件夹放上去就行了，差点就干这种傻事了。不过我后台是这样在服务器跑的，不知道有没有错。对于webpack为我们做了什么还是需要去学习的，而不是单纯的会用就行了。 ​ 部分页面截图 借鉴QQ音乐手机版的UI，但是关于和用户有关的都不能做，所以只好自由发挥了一些，有点四不像了 首页推荐和轮播图 歌单详情 歌词页面) 分类歌单（目前没做筛选） 排行榜 歌手 搜索 之后还需要完善的 拖动进度条改变进度都没做， 播放器瞬间没了灵魂 随机播放也没做，没有想好怎么实现真的随机播放 歌曲播放页面不能跳到歌手详情页面 首页推荐的请求非常大，没有做骨架屏来防止数据异步加载导致屏幕一闪， 同时也可以考虑从服务端渲染渲染做首屏优化 可以用 servicWorker 做离线缓存，比如以前播放过的音乐 最大的问题还是代码写的一坨坨，比较难看，不利于以后的维护，还是又不是不能用的程度 还有更多希望大家能给我一些宝贵的意见","link":"/2020/03/03/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%89%93%E9%80%A0%E7%AE%80%E6%98%93%E7%89%88QQ%E9%9F%B3%E4%B9%90webapp/"},{"title":"关于 Background的一些基本用法和使用技巧","text":"关于 Background的一些基本用法和使用技巧1.基本属性和用法12345678910111213141516 &lt;style&gt; .box1{ width: 1000px; height: 1000px; background-color:royalblue; background-image: url('../images/111.jpg'); background-position: 220px 220px; background-repeat: no-repeat; background-size: 100%; background-attachment: fixed; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; background-color 背景颜色 单词直接表示：background-color:red 16j进制表示：background-color:#fff (两个相同的位数可以简写成一个 #fffffff==#fff) RGB彩色模式: background-color:rgb(225,225,255) background-image：背景图片 background-image:url('../images/111.jpg') background-size:背景尺寸 百分比：background-size:60% 像素：background-size:200px cover: 把背景图片拓展到足够大，以使背景图片完全覆盖背景区域。背景图片也有可能某些部分无法显示出来 contain: 把背景图片拓展至最大尺寸，以使其高度和宽度完全适应内容区域 当只有一个值的时候,默认为图片的宽度，高度按比例自适应 background-repeat 背景图片重复 repeat(自动铺满) repeat-x（横向铺满） repeat-y（纵向铺满） no-repeat (不重复，只有一张) 2.多背景图片在CSS2.1中，元素只能添加一张背景图片。然而在CSS3中我们可以给元素添加多张背景图片。兼容性如下： 多张背景图片可以针对每一张设置单独的样式，对应的样式用逗号分开 如果属性值比背景图片要少时，name没有对应值的图片的样式以第一个样式为准； 多张背景图片的情况下这些图片从左到右层级一次减小，background-color最低 3. 背景渐变：background-image: linear-gradient背景渐变是基于background-image来设置的，具体语法可以参考 MDN。 兼容性如下： background-imgage: linear-gradient路径渐变（可以手动设置方向，默认是自下向上） background-image：repeating-linear-gradient 重复径向渐变 4. 背景定位 background-positionbackground-position 默认是定位在 padding-box的左上角 其属性可以设置成一下几种 百分比% 像素 px 位置（top、right、bottom、left、center） 在只设置一个值的时候，另外一个值默认为center 或者50%。 padding-box的左上角坐标为（0,0）/（left，top） 1234567891011121314151617 &lt;style&gt; .box1{ /* width: 400px; */ height: 400px; background-image: url('../images/222.jpg'); padding: 50px; border: 1px solid red; background-position: top; /* background-size: contain; */ background-repeat: no-repeat; background-color: darkkhaki; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 背景重复 background-repeatbackground-repeat 除了常见的几个 repeat、repeat-x，repeat-y 以及 no-repeat 以外，还在CSS3 中新加了两个值： space 和 round。其兼容性如下图所示： 背景图片小于容器时 background-repeat:space 在保证不缩放的前提下尽可能多的重复图片，并等分图片中间的空隙 ​ ​ background-repeat:round 在尽可能多的重复图片的前提下，拉伸图片以铺满容器 ​ ​ 背景图片大于容器时 background-repeat:space 在不缩放的前提下裁剪图片，只保留在容器内的部分 ​ ​ background-repeat:round 缩小图片以铺满容器，长宽与容器尺寸一致（未按比例缩放，图片极有可能变形） 5. 背景相对位置 background-originbackground-origin规定 background-position 属性相对于什么位置来定位。属性值有 content-box、 padding-box 、 border-box 三个。默认是padding-box 6. 背景绘制区域 background-clipbackground-clip 属性规定背景的绘制区域。默认值为 border-box，其属性值同 background-origin 一样，不过表现大不相同。其兼容性如下： background-clip: content-box ​ ​ background-clip: padding-box ​ ​ background-clip: border-box` ​ ​ 7. 背景大小 background-size感觉这个属性很常见吧，其实它也是 CSS3 中新加的属性。 CSS2.1 中，背景图片大小是无法设置的。background-size 除了常见的设置大小和百分比之外，还有两个特殊的属性：contain 和 cover background-size: contain 图片长宽不相同时，把图片按比例缩小至较长的一方完全适应内容区域为止，多用于背景图片比元素大的情况。 ​ ​ background-size: cover 图片长宽不相同时，把图片按比例放大至较短的一方完全适应内容区域为止，以使背景图像完全覆盖背景区域，多用于背景图片比元素小的情况。 ​ ​ 8. 背景固定 background-attachment有时候在一些网站上会看到，滚动页面的时候，背景图片是固定的。那就是使用 background-attachment: fixed 做到的。 background-attachment: fixed 背景固定 background-attachment: scroll 背景随页面滚动而滚动（默认） 9. 扩展属性 background: element一个特殊的扩展属性，可以将某个元素设置为另一元素的背景。惊不惊喜，意不意外！不过这个属性只有 FireFox 4+ 的浏览器可以使用，并且需要加上浏览器前缀。 background: element(#id) 12- demo1 作为背景的是非图片元素时，背景样式与原元素相同 &lt;style&gt; .div { width: 200px; height: 200px; background: element(#button) no-repeat; background: -moz-element(#button) no-repeat; } #button { width: 150px; height: 20px; margin: 50px; color: #0470f4; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;div1&quot;&gt; &lt;button id=&apos;button&apos;&gt;这是按钮&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; 1234![图片](https://user-gold-cdn.xitu.io/2020/1/12/16f98e971b209ffc?imageslim)- demo2 当设置为背景的元素是图片时，背景图不会随原图的大小样式改变而改变，不过平铺等背景样式依然是支持的 .div { width: 200px; height: 200px; border: 10px dashed #0ff; background: element(#img1); background: -moz-element(#img1); } #img1 { width: 50px; } L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"log\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/haruto.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":300},\"mobile\":{\"show\":true}}); ```","link":"/2020/01/13/%C2%96%C2%96%E5%85%B3%E4%BA%8E-Background%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"title":"文档对象模型-DOM","text":"​ DOM （文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描 绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM 脱胎于Netscape 及微软公司创始的 DHTML（动态 HTML），但现在它已经成为表现和操作页面标记的真正的平台、语言中立的方式。 ​ 1998 年 10 月 DOM１级规范成为 W3C 的推荐标准，为基本的文档结构及查询提供了接口。本章主要讨论与浏览器中的 HTML 页面相关的 DOM1 级的特性和应用，以及 JavaScript 对 DOM1 级的实现。IE、Firefox、Safari、Chrome 和 Opera 都非常完善地实现了 DOM。 需要注意的是IE中的所有DOM 对象都是以COM对象的形式实现的。这意味着IE中的DOM对象与原始的JavaScript 对象的行为或者活动特点并不一致。 操作DOM节点 appendChild（） 是向 childNodes 列表的末尾添加一个节点，并返回新的节点 123var returnedNodes = someNode.appendChild(newNode) alert(returnedNodes === newNode) //true alert(someNode.lastChild === newNode) //true 如果传入的节点已经存在于被传入的对象中了，那么会将该对象放到 childNodes 的末尾。这样我们可以把第一个子节点传入 appendChild 中，从而将第一个节点放到末尾。 123var returnedNode = someNode.appendChild(someNode.firstChild)alert(returnedNode === someNode.lastChild) //truealert(returnedNode === someNode.first) //false 如果想要把节点放到对象 childNodes 列表的某个特定位置，而不是像 appendChild 一样只能放到末尾，那么我们可以使用 insertBefore() 方法。这个方法接收 两个参数 ：要插入的节点和作为参照的节点。插入节点时会变成被参照节点的一个同胞节点（即previousSibling），同返回时被插入的节点 。如果第二个参数为 null ，那就相当于执行了 appendChild() 12345678//被参照的节点为 nullvar returnedNode = someNode.insertBefore(newNode,null)alert(newNode === someNode.lastNode) //true//将节点插入到第一个节点var returnedNode = someNode.insertBefore(newNode,someNode.firstChild)alert(returnedNode === newNode) //truealert(newNode === someNode.firstNode) //true 虽然有 insertBefore() 但是没有 insertAfter(),其实有没有都无所谓，用一个就可以实现了。 前面两个方法都是插入节点，下面这个方法 replaceChild 可以移除节点，该方法接收两个参数： 要插入的节点和要替换的节点，要替换的节点将有这个方法返回并从文档树中移除，同时由要插入的节点代替。直接看下面的例子吧： 1234567// 替换第一个节点var returnedNode = someNode.replaceChild(newNode,someNode.firstChild)alert(newNode === someNode.firstChild ) //true//替换第n个节点someNode.replaceChild(newNode,someNode.childNodes[n])someNode.replaceChild(newNode,someNode.childNodes.item(n)) 使用 replaceCHild() 插入一个节点后，被替换的节点的所有关系指针都会被新插入的节点所复制，从技术上来看我们还是可以访问的到这个被替换的节点，但是这个节点已经脱离了文档，可以理解为文档游离碎片。 如果只想移除节点而非替换，可以使用 removeChild() 。这个方法只接受一个参数，不用想都知道就是我们需要移除的节点，并且返回被移除的节点。直接看代码 12345//移除最后一个节点var removedNode = someNode.replaceChild(someNode.lastNode)//移除节点本身childNode.pare 和上面替换方法一样，被移除的节点还是存在于文档，但是在文档当中没了一席之位，也算是文档游离碎片。 前面介绍的四个方法操作的都是某个节点的子节点，也就是说使用这些方法必须先获取到 父节点，但是并不是所有节点都有子节点，如果在不支持子节点的节点使用这些方法会报错。下面两种方法是所有节点都有的 cloneNode()方法的作用是复制节点， 该方法接收一个布尔值参数，表示是否执行深拷贝。复制后返回的节点归文档所有，但此时并没有父节点。使用如下： 123456789101112//html&lt;ul&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 1&lt;/li&gt;&lt;/ul&gt;var deepList = myList.cloneNode(true)allert(deepList.childNodes.length) //3(IE &lt; 9) or 7(other browers)var shallowList = myList.cloneNode(false)allert(shallowList.childNodes.length) //0 cloneNode() 不会复制 添加到DOM节点的 JavaScript 属性，例如时间处理程序。这个方法只复制特性、在明确指明第一个参数true的情况下会复制所有子节点，其他一切都不会复制。IE在此存在一个bug，即他会复制事件处理程序，在我们复制前最好移除事件处理程序。 最后一个方法是 normalize() ，该方法的唯一作用是处理文档树中的文本节点。由于解析器的实现或者DOM操作等原因，可能会出现文本节点不包含文本或者连续出现两个文本节点的情况。在一个节点调用此方法后，会在该节点的子节点上进行查找。如果发现了空节点则删除；如果找到了相邻的文本节点则将他们合并成一个节点。 Document 类型​ JavaScript通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument(继承自Document类型) 的一个实例。即 document.__prototype__ === HTMLDocumentt.prototype 。表示整个HTML页面。而且 document 对象是 window 对象的一个属性，可以作为全局变量来访问。 Document节点具有以下特点： nodeType的值为9 nodeName 的值为“#document” nodeValue 的值为 null parentNode 的值为null ownerDocument的值为null 其子节点可能是一个DocumentType（最多是一个）、Element （最多一个）、ProcessingInstruction或 Comment document 对象提供了两个方法快捷访问其子节点 123456var html = document.documentElementalert(html === document.childNodes[0]) //truealert(html === document.firstChild) //truevar body = document.body//这个方法是平时开发比较常见的 还有一个方法是获取到DocumentType 的，通常将 &lt;!DOCTYPE&gt;标签看做一个与文档其他部分不同的实体，可以通过doctype属性访问到。 12var doctype = document.doctype//获得对&lt;!DOCTYPE&gt;的引用 文档类型​ 作为 HTMLDocument 的一个实例， document 对象还有一些 标准的 Document 对象所没有的属性。这些属性提供了 document 对象所表现的网页的一些信息。其中第一个属性是 title 12345//取得文档标题var originTitle = document.title//修改文档标题document.title = &quot;A new title&quot; ​ 下面三个属性都是对网页的请求有关，他们是 URL、 domain 、 referrer。 URL 属性包含页面完整的URL，domain属性只包含页面的域名，而 referrer则保存了链接到当前页面的那个页面的URL，即由哪个页面跳转过来的。在没有来源页面的情况下，referrer属性可能会包含空字符串。 ​ 所有这些信息都会存在于请求的 HTTP 头部，只不过是通过这些属性让我们可以在 JavaScript 中访问到而已，来看下面的例子。 12345678//取得完整的URLvar url = document.URL//取得域名var domain = document.domain//取得来源页面的URLvar referrer = document.referrer 在这三个属性当中只有 domain是可以设置的，但是出于安全考虑也不是可以设置成任何值。如果URL中包含一个子域名，例如 p2p.wrox.com，那么就只能将domain设置成“”wrox.com“。不能将domain设置为URL不包含的域 123//假设页面来自 &quot;p2p.wrox.com&quot;document.domain = &quot;wrox.com&quot; //OKdocument.domian = &quot;baidu.com&quot; //报错 ​ document.domain 的设置还有一个限制，如果域名一开始是松散的（loose），那么就不能在设置为紧绷的（tight）。如下面例子所示。 123//假设页面来自 &quot;p2p.wrox.com&quot;document.domain = &quot;wrox.com&quot; //这是可以的document.domian = &quot;p2p.wrox.com&quot; //不能再往下加子域名 查找元素 document.getElementById()这个方法就不多说了，返回与传入参数匹配的元素，没找到则返回null。需要注意的是在IE7及以下的版本对参数是不区分大小写的，还有如果有表元素的name属性和要查找的元素id相同，且表单元素在前面，那就完蛋了，你可能就获取不到你想要查找的元素了。 document.getElementsByTagName()返回一个HTMLCollection ，和nodeList很相似有一点不同的是访问HTMLCollection 时除了通过索引和 item()方法之外 ，还支持 namedItem(),可以快速通过名字定位到我们想要的元素。 123456&lt;img src=&quot;xxx.jpg&quot; name=&quot;myImg&quot;/&gt;var imgs = document.getElementsByTagName('img')var myImg = imgs.namedItem('myImg')//还可通过下面的形式var myImg = imgs['myImg'] //最终会调用 namedItem() 虽然说标准规定标签名需要区分大小写，但是为了最大限度地与既有的HTML页面兼容，穿给 gelElementsByTagNma() 是可以不区分大小写的。但是对于XML包括XHTML来说是需要区分大小写的。 关于查找元素就先介绍到这里。 Element类型​ 除了 Document 类型之外， Element 类型要算是最常用的类型了。具有以下特点： nodeType 的值为1 nodeName 的值为元素的标签名 nodeValue 的值为null parentNode可能是Document或者Element 其子节点可能是Element、Text、ProcessingInstruction、、CDATASection 或 EntityReference。 要访问元素的标签名，可以使用 nodeName 属性，也可以使用 tagName 属性；这两个属性会返回 相同的值（使用后者主要是为了清晰起见）。以下面的元素为例： 12345&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;var div = document.getElementById('myDIv')alert(div.tagName) //'DIV'alert(div.tagName === div.nodeName) //true 1. HTML元素​ 所有HTML元素都有 HTMLElement 类型表示，不是直接通过这个类型，而是子类型。 HTMLElement类型也是继承了Element并添加了一些属性。 添加的这些属性分别相应于每个HTML元素都存在下列标准特性： id, 元素在文档中的唯一标识符 title ，有关元素的附加说明信息，一般通过工具提示条显示出来。 lang ，元素内容的语言代码，很少使用 dir ，语言的方向，值为”ltr“（left to right），或者”rlt”,也很少使用 className 与元素的class对应，即为元素指定CSS类。 获取特性 getAttribute() setAttribute() removeAttribute() 需要注意的是getAttribute()传入的特性名应该与实际的特性名相同，所以想要获取到class的话需要‘class’，而非‘className’，而且还可以获取自定义属性（即标准HTML语言当中没有的特性） 任何元素的所有特性都可以通过DOM元素本身的属性来访问，当然 HTMLElement也会有5个属性与相应的特性意义对应。不过只有公认的特性（非自定义）才会添加到DOM对象中。 12345&lt;div id=&quot;myDiv&quot; align=&quot;left&quot; myAttribute=&quot;hello&quot;&gt;&lt;/div&gt;alert(div.id) //&quot;myDiv&quot;alert(div.align) //&quot;left&quot;alert(div.myAttribute) //undefined(IE除外) ​","link":"/2020/01/20/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8BDOM/"},{"title":"算法学习-00","text":"贪心算法解决股票买入卖出最优 广度优先搜索 深度优先搜索 二分查找 二分查找二分查找的条件 Sorted（单调递增或者递减） Bounded（存在上下界） Accessible by index （能够通过索引访问） 每次取得数组的 middle， ``left，right边界，和target` 进行比较，假设数组是递增的。 如果 middle 等于目标值，直接放回结果；如果目标大于 middle ，left=middle + 1 ，需要查询数组变为原来的一半，时间复杂度为 lgN 题目实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2示例 2: 输入: 8 输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 解题思路 123456789101112131415161718/** * @param {number} x * @return {number} */var mySqrt = function(x) { var left = 0, right = x; if(x == 1) return 1; while(right - left&gt;1) { let middle = Math.floor((left+right)/2); if(middle &gt; (x/middle)) { right = middle; } else { left = middle; } } return left;}; 使用牛顿迭代法，具体的原理网上查阅资料 123456789101112/** * @param {number} x * @return {number} */var mySqrt = function(x) { //牛顿迭代法 var r = x; while( r*r &gt; x) { r = (r + x/r) /2 } return Math.floor(r)}; 不知道为啥会超时，很奇怪 字典树实际要解决的问题： ​ 在输入框输入部分文字后，会在下面显示出相关的信息列表 基本结构 Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频的统计。 它的优点是：最大限度减少了无畏的字符串比较，查询效率比哈希表高。 核心思想是空间换时间，利用字符串的公共前缀来降低查询时间来提高效率基本性质 根节点不包含任何字符，除了根节点外每个节点都包含一个或者不包含字符 从根节点到每一个节点，路径上所有字符连接起来；为该节点对应的字符串 每个节点的所有子节点包含的字符都不相同 实际问题实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 123456789101112Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Initialize your data structure here. */var Trie = function() { this.root = {}; //当节点出现这个属性，表示已经结束 // 用来判断是等于 还是只是前缀而已 this.end_of_word = '*'; };/** * Inserts a word into the trie. * @param {string} word * @return {void} */Trie.prototype.insert = function(word) { let node = this.root; for(let i = 0; i &lt; word.length; i++) { let key = word[i]; if(key in node) { // 如果存在的话 node等于这个字符的值 node = node[key]; } else { node[key] = {}; node = node[key]; } } node['end_of_word'] = '*';};/** * Returns if the word is in the trie. * @param {string} word * @return {boolean} */Trie.prototype.search = function(word) { let node = this.root; for(let i = 0; i &lt; word.length; i++) { let key = word[i]; if(key in node ) { node = node[key]; }else{ // 这个字符不在，返回false return false; } } // 虽然所有的字符都存在，但是还要判断是不是前缀 return node['end_of_word'] === '*';};/** * Returns if there is any word in the trie that starts with the given prefix. * @param {string} prefix * @return {boolean} */Trie.prototype.startsWith = function(prefix) { var node = this.root; for(var i = 0; i &lt; prefix.length; i++) { let key = prefix[i]; if(key in node) { node = node[key]; }else { return false; } } return true;};/** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */ 实际问题二：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 示例: 12345678910输入: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']]输出: [&quot;eat&quot;,&quot;oath&quot;] 说明:你可以假设所有输入都由小写字母 a-z 组成。 提示: 你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？ 如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * @param {character[][]} board * @param {string[]} words * @return {string[]} */var findWords = function(board, words) { var root = {}; var trie = new Trie(); var end_of_word = 'end' var dx = [1,-1,0,0],dy = [0,0,-1,1];//用于遍历上下左右相邻值 // 字典树 function Trie() { this.root = {}; } Trie.prototype.insert = function(item) { var node = this.root; for(let i = 0; i &lt; item.length; i++) { let key = item[i]; if(key in node) { node = node[key]; }else { node[key] = {}; node = node[key]; } } node[end_of_word] = '*'; } words.forEach( item =&gt; { trie.insert(item); }) var m = board.length, n = board[0].length; var res = new Set(); for(let i = 0; i&lt;m; i++) { for(let j = 0; j &lt; n; j++) { var currObj = trie.root; if(board[i][j] in currObj) { _dfs(board, currObj, '', i, j ) } } } // 深度优先搜索 function _dfs (board, currObj , currWord, i, j) { // 给结果复制给word，字典树向下推进一层。 currWord += board[i][j]; currObj = currObj[board[i][j]]; //如果这个字典树结束了 添加结果 if(end_of_word in currObj) { res.add(currWord); } var tmp = board[i][j];//保存当前值 board[i][j] = '*'; for(let k = 0; k&lt;4; k++) { var x = i + dx[k], y = j + dy[k]; // 判断索引合法，而且没有被用过，且存在于字典表里面 if(0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; board[x][y] != '*' &amp;&amp; board[x][y] in currObj) { _dfs(board, currObj, currWord, x, y); } } board[i][j] = tmp;//恢复原始值 } return [...res];}; 位运算的作用 判断奇偶 1234function isOdd (n) { return n&amp;1}//根据位运算 与操作 最后一位为0 为偶数 为1 是技术 获取一个二进制数 1 出现的次数 123456789101112131415/** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { var count = 0; while(n!=0) { n = n &amp; (n-1); count++; } return count;};// 一个二进制数减1 第一个1出现的位变0 后面的为变为1// 10010 减1 后变成 10001//再两者相与得到新的数 继续比较下去 第二种方法 12345678910var hammingWeight = function(n) { var res = 0, mask = 1; for(let i = 0; i&lt;32 ; i++) { if((n &amp; mask) != 0) { res++; } mask &lt;&lt;= 1; } return mask;} 判断一个数是不是 2 的冥次方 问题分析，只要是 2 的 n次方，1出现的次数肯定只有一次 根据 x = x &amp; (x - 1) 之后不等于0 就可以判断这个数不是 代码实现： 1234567/** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { return n&lt;=0 ? false : (n &amp;= n-1) === 0}; 给定一个非负整数 num。对于 *0 ≤ i ≤ num *范围中的每个数字 *i *，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 12输入: 2输出: [0,1,1] 示例2： 12输入: 5输出: [0,1,1,2,1,2] 代码实现： 12345678910111213/** * @param {number} num * @return {number[]} */var countBits = function(num) { let res = []; res[0] = 0; for (let i = 1; i &lt;= num; i++) { res[i] = res[i &amp; (i-1) ]+1 } return res;}; 动态规划 递归 + 记忆化 —&gt; 递推 状态的定义： opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of( opt[n-1],opt[n-2], …. ) 最优子结构 DP vs 回溯 vs 贪心 回溯（递归） — 重复计算 贪心-— 永远局部最优 DP — 记录局部最优子结构/多种记录值","link":"/2020/02/05/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-00/"},{"title":"算法学习专题-位运算","text":"首先了解一下一下常用的位运算 &amp; 只有 1 和 1 相与才为1 | 0和0 相或等于0 ^ 亦或， 两个不一样的为1， 一样的为0，可以看做不进位的加法 12a ^ a = 0 两个数一样亦或为0a ^ 0 = a 任何数亦或0都是它本身， 因为可以看做不进位加法 ​ ~ 取反 &lt;&lt; 1101 &lt;&lt; 2 = 110100 左移和右移可以看做乘以2或除以2 &gt;&gt; 1101 &gt;&gt; 2 = 11 1. 2的整数次冥给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 思路：首先我们来看一下2的冥次方都是怎么样的 122^3 = 10002^5 = 100000 和明显只有最前面的一个1， 后面的全是0，我们可以用一个数减1然后再与原来的数相与,为0的话就是2的冥次方 12345x: 2^3 = 1000 x-1 = 0111x &amp; x-1 = 0x = 10011 x-1 = 10010x &amp; x-1 = 10010 代码实现： 12345678910/** * @param {number} n * @return {boolean} */var isPowerOfTwo = function(n) { return n&lt;=0 ? false : (n &amp;= n-1) === 0};//还有一种方法是 n &amp; -n === n//如果不是2的冥次方 得出的结果是小于n的 2.二进制表示中质数个计算置位给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation 示例 1: 1234567输入: L = 6, R = 10输出: 4解释:6 -&gt; 110 (2 个计算置位，2 是质数)7 -&gt; 111 (3 个计算置位，3 是质数)9 -&gt; 1001 (2 个计算置位，2 是质数)10-&gt; 1010 (2 个计算置位，2 是质数) 实例2： 123456789输入: L = 10, R = 15输出: 5解释:10 -&gt; 1010 (2 个计算置位, 2 是质数)11 -&gt; 1011 (3 个计算置位, 3 是质数)12 -&gt; 1100 (2 个计算置位, 2 是质数)13 -&gt; 1101 (3 个计算置位, 3 是质数)14 -&gt; 1110 (3 个计算置位, 3 是质数)15 -&gt; 1111 (4 个计算置位, 4 不是质数) 这题的直接意思就是统计一个二进制数中 1 出现的个数， x &amp; x-1相当于把这个数中第一个1去掉，如果等于0就说明1已经移除完了 也可以直接使用 &gt;&gt; 右移运算，如果第一位是1的话就统计数加1 还有一个关键的，由于数的位数是有限的，我们可以认为1的个数不会超过19 解法一(每次右移1位，末尾是1的话就数量加1)1234567891011121314151617/** * @param {number} L * @param {number} R * @return {number} */var countPrimeSetBits = function(L, R) { //这里是因为2进制的位数有限 var primes = [2, 3,5,7,11, 13, 17, 19]; var res = 0; for(let i = L; i &lt;= R; i++) { let count = 0; //每个二进制数1出现的个数 for(let k = i; k ; k &gt;&gt;= 1) count += k&amp;1; if(primes.indexOf(count) !== -1) res++; } return res;} 解法二 （n &amp;= n-1 来统计1 出现的个数）123456789101112131415var countPrimeSetBits = function(L, R) { //这里是因为2进制的位数有限 var primes = [2, 3,5,7,11, 13, 17, 19]; var res = 0; for(let i = L; i &lt;= R; i++) { let count = 0, k = i; while(k) { //如果不为0的话，说明还有1 k &amp;= k-1; count++ } if(primes.indexOf(count) !== -1) res++; } return res;} 3. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 来源：力扣（LeetCode）链接： 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 解题思路因为其他数都会出现两次，根据亦或的原理，一个数亦或它本身结果为0，那么最后一个只出现了一次的数亦或0还是会等于本身，所以只要将所有数亦或，返回最后的结果 代码实现： 123456789101112/** * @param {number[]} nums * @return {number} */var singleNumber = function(nums) { var res = 0; for(let i = 0; i &lt; nums.length; i++) { res ^= nums[i]; } return res;} 4. 只出现一次的数字（11）给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,3,2]输出: 3 示例 2: 12输入: [0,1,0,1,0,1,99]输出: 99 解题思路：把每一个数看做一个32位二进制数，统计在每一位中1和0的个数，因为要么是3个或者要么是1个，所以在每一位出现1和0的总和应该是 3N 或者 3N+1 ，3N的话表示目标数在这里1没有出现， 3N+1的话表示目标数在这一位有出现过1。 代码实现： 12345678910111213/** * @param {number[]} nums * @return {number} */var singleNumber = function(nums) { let res = 0; for(let bit = 0; bit &lt; 32; bit++) { let counter = 0; for(let num of nums) counter += (num &gt;&gt; bit) &amp; 1; res += (counter % 3) &lt;&lt; bit } return res} 5.只出现一次的数字（111）给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例 : 12输入: [1,2,1,3,2,5]输出: [3,5] 解题思路： 这题除了那两个单独出现的数之外，可以肯定其他的数依次亦或起来肯定是等于0的，最后一次亦或的结果应该那两个单独出现的数亦或的结果，既然这两个数不相等，那它们两个亦或的结果肯定至少有一位是1的，否则的话它们两个不就相等了。 在上面的思路基础之上，把亦或出来的结果找到出现 1 的位数 k，也就是第 k 位，再把第 k位按照0 和 1 分为两组，为1的一组有一个只出现了一次的数 single1， 为2的一组有一个只出现了一次的数 single2，再把这两组其中一组亦或出的结果就是我们要求的一个数。 123//在求出single1的基础之上single = single1 ^ single2single2 = single ^ single1 代码实现： 12345678910111213141516171819/** * @param {number[]} nums * @return {number[]} */var singleNumber = function(nums) { var s = 0; //求出所有数亦或后的结果，也就是 s1和s2亦或的结果 for(let num of nums) s ^= num; //统计在第K位，出现了1 let k = 0; while( !((s &gt;&gt; k) &amp; 1) ) k++; //找到第一个单独出现的数字 let s1 = 0; for(let num of nums){ if( (num &gt;&gt; k) &amp; 1 ) s1 ^= num; } return [s1, s ^ s1]} 6.数字的补数给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。 示例 1: 123输入: 5输出: 2解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 示例 2: 123输入: 1输出: 0解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。 解题思路：首先搞清楚取反简单的理解就是 二进位上的 1 变成0 ，0变成1，比如 10010 变成 01101 我们可以依次对该数的第一位取反然后左移这一位对应的位数，再把它加到结果上。 比如第三为是1， 那么 res += 0 &lt;&lt; 3 代码实现： 123456789101112/** * @param {number} num * @return {number} */var findComplement = function(num) { var res = 0, place = 0; while(num) { res += ( (num &amp; 1) ? 0 : 1 ) &lt;&lt; place++; num &gt;&gt; 1; } return res;} 7. 两整数之和不使用运算符 + 和 - ，计算两整数 a 、b 之和。 示例 1: 12输入: a = 1, b = 2输出: 3 示例 2: 12输入: a = -2, b = 3输出: 1 解题思路： 暂时还不是很能理解这题，希望下次来看的时候能补充 代码实现： 12345678910/** * @param {number} a * @param {number} b * @return {number} */var getSum = function(a, b) { if(b === 0) return a; var sum = a ^ b, carry = (a &amp; b) &lt;&lt; 1; return getSum(sum, carry);}","link":"/2020/03/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"算法数据结构-链表篇","text":"从今天开始系统的去学习算法和数据结构，不能这个题目做一下，那个题目做一下，这样学习的反馈很差。需要系统的去练习，而不是为了刷题而刷题，要跳出舒适圈，明确自己的目标。 1. 反转链表（Leecode-206）反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路： 从头结点开始，保存每个节点的 next 节点作为该节点的前继节点（虽然没有这一说法），当前节点的后继节点变为上一个节点，头结点的话就是 null ，紧接着下一节点的前继节点 pre 为当前节点 cur。 重要的是需要先保存当前节点的后继节点，不然更改后继节点后就失去了和后继节点的关系 方法一 迭代代码实现： 12345678910111213141516171819202122//链表结构声明function listNode (val) { this.val = val; this.next = null}/** * @param {ListNode} head * @return {ListNode} */ function reverseList (head) { if(!head) return null; let cur = head, pre = null; while(cur) { //保存后继节点 let next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } 方法二 递归代码实现： 12345678910function reverseList (head) { let _reverse = function (pre, cur) { if(!cur) return pre; let next = cur.next; cur.next = pre; //当前节点作为下次递归的前继节点 return _reverse(cur, next); } return _reverse(null, head) } 2. 区间反转链表题目：（Leecode-92） 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 思路： 其实和上面反转链表是差不多的，只不过在反转区间之前记录下前继节点，反转之后记录下后继节点，可以说是换汤不换药。重点在前后节点的记录 方法一：迭代 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @param {number} m * @param {number} n * @return {ListNode} */var reverseBetween (head, m, n) { let count = n - m; let p = nodeList = new ListNode(); p.next = head; for(let i = 0; i &lt; m-1; i++) { p = p.next; } let front, pre, cur, tail, next; front = p; // 保留区间的前继节点，最后和区间交换后的首节点相连 tail = pre = p.next; //保留区间的首节点 cur = pre.next; for(let i = 0; i &lt; count; i++) { next = cur.next; cur.next = pre; pre = cur; cur = next; } //将它们连接起来 front.next = pre; //pre是区间反转后的首节点 tail.next = cur; //cur是区间n后面的首节点 return nodeList.next; } } 方法二 递归代码实现： 123456789101112131415161718192021222324252627282930313233function reverseBetween (head, m, n) { //递归函数 function _reverse (pre, cur) { if(!cur) return pre; let next = cur.next; cur.next = pre; return _reverse(cur, next); } var p = nodeList = new ListNode(); nodeList.next = head; for(let i = 0; i &lt; m-1; i++) { p = p.next; } let front, tail; front = p; //保存区间的前继节点 let start, end; //区间的开始和结束节点 start = front.next; for(let i = m-1; i &lt; n; i++ ) { p = p.next; } end = p; tail = end.next; //保存区间的后继节点 end.next = null; //递归结束的条件 front.next = _reverse(null, start); start.next = tail; return nodeList.next; } } 这里注意的是调用递归的时候不要 _reverse(start, start.next) ; 因为当m == n 的时候递归不能跳出来 3. 两个一组反转链表Leecode 22 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 方法一 迭代解题思路：创建一个新的链表 p，每次取 p.next 和 p.next.next 作为 node1，node2 ,紧接着交换两者的值；即 node1.next = node2.next,然后 node2.next = node1。 再把 p的值复制给 node1,继续操作直到 p.next 或 p.next.next 不存在。 代码实现： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var swapPairs = function(head) { //判断链表不存在或者长度只为一的情况 if(head == null || head.next == null) return head; var p = listNode = new ListNode(); let node1,node2; while((node1 = p.next) &amp;&amp; (node2 = p.next.next)) { //交换 node1 和 node2 的值 node1.next = node2.next; node2.next = node1; p.next = node2; p = node1 } return listNode.next;} 方法二 递归代码实现： 1234567var swapPairs = function (head) { if(head == null || head.next = null ) return head; var node1 = head, node2 = head.next; node1.next = swapPairs(node2.next); node2.next = node1; return node2;} 递归的代码更加简洁，但是也不好理解，需要多花点时间 4. K个一组翻转链表Leecode 26 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 递归思路和之前的原理是差不多了，多了几个步骤，判断是否为K个，不够的话直接返回就是了。 每一次的 head 节点一开始指向 pre 一个null 节点，最后结束的时候 head 节点为被反转后的尾结点。 再置 head.next = reverseKGroup ( cur, k) ,将每K个区间依次连接起来。 该函数返回的 是 pre 节点，也就是上一区间的结束节点，即上一区间反转后的首节点。 说也说不清楚，直接看代码和注释吧： 123456789101112131415161718192021var reverseKGroup = function (head, k) { var pre = null, cur = head; var p = head; //一个试探指针 for(let i = 0; i &lt; k; i++) { //当第一个或者后面两个有一个为null， 直接返回head if(p == null) return head; p = p.next;//继续向下试探 } for(let i = 0; i &lt; k; i++) { let next = cur.next; //在这里第一个head节点的尾结点虽然被复制null //但是在最后会作为该区间的尾结点和下个递归返回的 pre 首节点相连 cur.next = pre; pre = cur; cur = next; } //cur是下一个反转区间的head首节点 head.next = reverseKGroup(cur, k); //这里的pre也就是第一个区间反转后的首节点 return pre;} 方法二 迭代迭代的思路主要是一开始要判断一下链表的长度，方便循环每组进行反转。 代码实现： 123456789101112131415161718192021222324252627282930313233var reverseKGroup = function (head, k) { var count = 0; var p = head; while(p != null) { count++; p = p.next; } //需要循环的次数 var countLoops = Math.floor(count/k); //创建一个链表和一个试探指针 var p = listNode = new ListNode(); listNode.next = head; for(let i = 0; i &lt; countLoops; i++) { let pre = null, cur = p.next; //这里还是和上面一样，反转链表 for(let i = 0; i &lt; k; i++) { let next = cur.next; cur.next = pre; pre = cur; cur = next; } //反转之后 pre为当前区间的首节点， cur为下个要反转区间的首节点 //p在第一次是和listNode相等的，p.next也就是一开始的head，而head变成了尾结点 let start = p.next; p.next = pre; start.next = cur; p = start; //这几行是最难理解的了 p的作用也很容易搞混淆 } return listNode.next;} 环形链表1. 如何检测环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 思路： 用Set或者对象的键唯一的特点来对已经访问过的节点进行记录，如果出现了两次，这说明链表成环了 用一个快指针一个慢指针，慢指针一次走一步，快指针一次走两步，如果两者相遇了，说明链表形成环 方法一 ：Set去重代码实现： 1234567891011121314151617181920212223/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */ var hasCycle = function (head) { var set = new Set(); var p = head; while(p) { //已经走过一次的话，确认是环 if(set.has(p)) return true; set.add(p); p = p.next; } return false; } 方法二： 快慢指针代码实现： 12345678910var hasCycle = function (head) { var fast = head, slow = head; while(fast &amp;&amp; fast.next) { fast = fast.next.next; slow = slow.next; if(fast == slow) return true; } return false;} 如何找到环形链表的起始点给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 来源：力扣（LeetCode） 链接142：https://leetcode-cn.com/problems/linked-list-cycle-ii 迭代思路其实和上面的差不多，因为用去重的方法如果有环的话，肯定是在环开始的地方找到的 代码实现： 123456789101112131415var detectCycle = function (head) { var map = new Map(); var p = head; //记录索引 for(let i = 0;p != null; i++) { if(map.has(p)) { return p; } map.set(p,i); p = p.next; } //p为null，表示肯定有结束，链表不为环 return false} 当然还有使用快慢指针的方法，不过推导有点难理解。下次有机会再补充一下 链表合并1. 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例: 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：leecode21题 思路：每次比较两个节点的大小，返回较小的节点作为后继节点。思路还是比较清晰的 递归解法12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var mergeTwoLists = function (l1, l2) { var _merge = funtion (l1, l2) { //如果有一个链表结束了，就可以直接返回另外一个了 //另外一个是有序的，递归就可以结束了 if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val) { l1.next = _merge(l1.next, l2); return l1; } else { l2.next = _merge(l1, l2.next); return l2; } } return _merge(l1, l2)} 迭代解法代码比较清晰，直接写啦 123456789101112131415161718192021222324var mergeTwoLists = function (l1, l2) { var p = listNode = new ListNode(); while(true) { if(l1 == null) { p.next = l2; break; } if(l2 == null) { p.next = l1; break } if(l1.val &lt; l2.val) { p.next = l1; l1 = l1.next; }else { p.next = l2; l2 = l2.next } p = p.next; } return listNode.next} 2 . 合并K个有序链表合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 来源： Leecode 23题 递归思路：可以和上面没什么区别，可以采用分治法。每次将数组分为两份，最后会返回 0，1,2个，在使用上面合并两有序链表的方法，最后再向上返回，汇总成一个合并好的。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode[]} lists * @return {ListNode} */var mergeKLists = function (lists) { var k = lists.length; var mid = Math.floor(k/2); //下面三种情况就可以不用再分治了 if(k == 0) return null; if(k == 1) return lists[0]; if(K == 2) return mergeTwoList(list[0], list[1]); //如果还是大于2，将数组变成两份 var l1 = lists.splice(0, mid); var l2 = lists; return mergeTwoList(mergeKLists(l1), mergeKLists(l2));}//var mergeTwoList = function (l1, l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val) { l1.next = mergeTwoList(l1.next, l2); return l1 } else { l2.next = mergeTwoList(l1, l2.next); return l2; } } 回文链表 - 找到一个链表的中点请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例2： 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路：还是利用两个指针，一个 slow 每次走一步， fast 每次走两步。找到这个链表的中点，找到中点后将中点后面的链表反转，再依次比较前后两个链表，有不相等的话直接返回 false 。 至于链表数量是奇数还是偶数的情况看下面代码注释，有明确的说明。 123456789101112131415161718192021222324252627282930313233343536var isPalindrome = function (head) { if(head == null || head.next == null) return true; var slow = head, fast = head, half; //判断快指针走到了末尾 while(fast &amp;&amp; fast.next) { fast = fast.next; slow = slow.next; } //这里分为链表熟练为奇数和偶数两种情况 //偶数的话： fast不为null，fast.next为null， //后面半部分为slow和slow之后的节点 //奇数的话：fast为null,fast.next为null //且后半部分为slow节点之后的节点 if(fast == null) { //偶数 half = reverse(null, slow); } else { half = reverse(null, slow.next) } //一次取节点和前部分的比较 while(half) { if(half.val == head.val) return false; half = half.next; head = head.next; } return true;}var reverse = function (pre, cur) { if(cur == null) return pre; let next = cur.next; cur.next = pre; return reverse(cur, next);} 到现在链表算是做完了，下次还有的话继续补充。参考掘金大佬 神三元 的博客：","link":"/2020/02/11/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8%E7%AF%87/"},{"title":"ES5中的数组","text":"Array类型 除了Object之外，Array类型恐怕是ECMAScript中最常用的类型了。而且，ECMAScript中的数组与其他多数语言中的数组有着相当大的区别。虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript中数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，第二位置来保存数值，用第三个位置来保存对象。以此类推。而且，ECMAScript数组的大小是可以动态调整的，既可以随着数据的添加自动增长以容纳新增数据。 创建数组的基本方式有两种。第一种是使用Array 构造函数,如下面的代码所示:​ 123var colors = new Array();var colors = new Array(20);var colors = new Array(&quot;red&quot;,&quot;blue&quot;,&quot;black&quot;); 另外在使用Array构造函数时也可以省略new操作符。如下面乐子所示，省略new操作符的结果相同 1var colors = Array(3); 创建数组的第二种基本方式是使用数组字面量表示法。数组字面量是由一堆包含数组项的方括号表示，多个数组之间以逗号隔开，如下所示：​ 1234567var color=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];var name=[]; //创建一个空数组var values=[1,2,3,]; //不要这样！这样会创建一个包含2或3项的数组var potions = [,,,,] //不要这样！这样会创建一个包含5或6项的数组alert(colors.length); //3alert(name.length); //0 数组的length属性很有特性————他不是只读的。因此，通过设置这个属性，可以从数组末尾移除项或向数组中添加新项。请看下面的例子：​ 1234colors.length=2;alert(colors[2]); //undefinedcolors.length=3;alert(colors[2]); //同样也会是undefined 利用length属性也可以方便地在数组末尾添加新项，如下所示：​ 1234567var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;white&quot;];colors[colors.length]=&quot;balck&quot;; //在位置3添加一个新的颜色 “black”colors[colors.length] = &quot;brown&quot;; //在位置4添加一个新的颜色 “brown”colors[99] = &quot;green&quot;;alert(colros.length); //数组的长度变成了100 因为在位置99添加了一个颜色alert(colors[66]); //undefined 因为位置3到98都是不存在的 所以返回undefined 检测数组 自从ECMAScript3做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页，或者一个全局作用域而言，使用 instanceof操作符就能得到满意的结果。 123if(value instanceof Array){ //对数组执行某些操作} instanceof操作符的问题在于，他假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架中传入一个数组，name闯入的数组与在第二个框架中原生创建的数组分别具有各自不同的函数。 为了解决这个问题，ECMAScript5新增了Array.isArray（）方法。这个方法的目的是最终确定某个值到底是不是数组，而不管他是在哪个全局执行环境中创建的。这个方法的用用法如下。​ 123if（Array.isArray(value)）{ //对数组执行某些操作 } 转化方法如前所述，所有对象都具有toLocaleString(),toString()和valueOf（）方法。其中，调用valueOf（）返回的还是数组本身，而调用数组的toString（）方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串会调用数组每一项的toString（）方法。来看下面这个例子。​ 1234var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;white&quot;];alert(colors.toString()); //red,blue,whitealert(colors.valueOf()); //red,blue,whitealert(colors); //red,blue,white 由于alert（）要接受字符串参数，所以他会在后台调用toString（）方法 另外toLocaleString()方法也会经常返回与toString（）和valueOf（）方法相同的值，但也不总是如此。当调用数组toLocaleString（）方法时，她也会创建一个数组值得以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocaleString（）方法，而不是toString（）方法。请看下面这个例子； 123456789101112131415161718192021var person1={ toLocaleString:function(){ return &quot;wang&quot;; }, toString:function () { return &quot;wang&quot;; }};var person2={ toLocaleString :function() { return &quot;junping&quot; }, toString:function(){ return &quot;jun&quot; }};var people=[person1,person2];alert(people); //wang,junalert(people.toString()); //wang,junalert(people.toLocaleString());//wang,junping 数组继承的toLocaleString（），toString（）和valueOf（）方法，在默认的情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用join（）方法，则可以使用不同的分隔符来构建这个字符串。join（）方法只接收一个参数，即用做分隔符的字符串，然后返回所包含所有数组项的字符串。请看下面的例子： 123var colors =[&quot;red&quot;,&quot;blue&quot;,&quot;white&quot;];alert(colors.join(&quot;!&quot;));alert(colors.join(&quot;,&quot;)); 如果数组中的某一项是null或者undefined，name该值在join（），toLocaleString（），toString（）和valueOf（）方法返回的结果以空字符串表示。 栈方法 push（）方法可以接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度。而pop（）方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。请看下面的例子： 12345678910var colors=new Array()；var count=colors.push(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;);alert(count) //3 因为push（）会修改并返回最后的数组长度count = colors.push(&quot;black&quot;);alert(count); //4var item = colors.pop; //取得最后一项alert(item) //&quot;black&quot;alert(colors.length); //3 可以将栈方法与其他数组方法连用，向下面这个例子一样： 1234567var colors=[&quot;red&quot;,&quot;blue&quot;];colors.push(&quot;brown&quot;); //添加一项colors[3]=&quot;black&quot;; //添加第四项alert(colors.length) //4var item=colors.pop();alert(item,colors.length); //&quot;black&quot;,3 队列方法栈数据结构的访问规则是LIFO（后进先出），而队数据结构的访问规则是FIFO（First-in-First-out，先进先出）。队列在列表末端添加，从列表的前端移除项。由于push（）就是在数组末端添加项，因此要模拟队列只需要数组前端取得项的方法。实现这一操作的数组方法就是shift（），它能够移除数组中的第一个项并返回该项，同时将属于组长度减1.结合使用shift（）方法和push（）方法，可以像使用队列一样使用数组。 12345678910var colors=new Array()；var count=colors.push(&quot;red&quot;,&quot;green&quot;);alert(count); //2count = colors.push(&quot;black&quot;);alert(count); //3var item = colors.shift();alert(item); //&quot;red&quot; 取得第一项并返回alert(colors.length); //2 还有一个unshift（）方法。顾名思义，和shift（）方法的作用相反：他能在数组的前端添加一个项并返回新数组的长度。因此使用unshift（）方法和pop（）方法可以从相反的方向模拟队列 重排序方法数组中以及存在两个可以直接用来重排序的方法：reverse（）和sort（）。 1234var values=[1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 这个0排列数组项————即最小的值在前面，依此到最大。为了实现排序，sort（）方法会调用每一个数0方法比较的也是字符串，如下所示：000 123`var values=[0,2,8,10,15];values.sort();alert(values); //0,1,10,15,5 但是你也看到了，如果我们想给数字排序的话，他会先把数字转化成字符串进行比较，就不会得到我们想要的从小到大的结果了 因此sort（）方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。一下就是一个简单的比较函数： 123456789function compare(value1,value2){ if(value1&lt;value2){ return -1; }else if(value1&gt;value2){ return 1; }else{ return 0; }} 这个比较函数可以适用于大多数的数据类型，只要将其作为参数传递给sort（）方法即可，如下面这个例子所示 12345var values=[0,1,2,5,10,15,25,1020];values.sort();console.log(values); //0,1,1020,15,2,25,5values.sort(compare);console.log(values); 当然也可以通过比较函数产生降序排列的结果，只要交换函数返回的值就可以 当然如果你想反转数原来的顺序，使用reverse（）方法要更快一些 123456789101112function compare2(value1,value2){ if(value1&lt;value2){ return 1; }else if(value1&gt;value2){ return -1; }else{ return 0; } } values.sort(compare2); console.log(values); //1020, 25, 15, 10, 5, 2, 1, 0 reverse()和sort()方法的返回值都是经过排序之后的数组 对于数值类型或者其他valueOf（）会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可 123function compare（value1,value2）{ return value2 - value1; } slice()方法 它能够基于当前数组中的一或多个项创建一个新数组。slice（）方法可以接收一个 或两个参数，即要返回项的起始和结束位置。在只有一个参数得到情况下，slice（）方法返回从该参数指定位置开始 到当前数组末尾的所有项。如果有两个参数，该方法返回其实和结束为止之间的项————但不包括结束位置的项。 注意，slice（）方法不会影响原数组。请看下面例子：​ 1234567console.log(&quot;slice()方法&quot;); var color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;black&quot;,&quot;white&quot;]; var color1=color.slice(1); var color2=color.slice(1,4); console.log(color1); console.log(color2); 如果slice（）方法的參數中有一個是負數，则用数组的长度再加上参数来确定相应的为止 比如在一个包含5项的数组上调用slice（-2，-1）与嗲用slice（3,4）得到的结果相同 下面我们来介绍splice（）方法，介个方法恐怕要算是最强大的数组方法了，他有很多种用法。splice（）的主要用途是想数组的中部插入项，但使用这种方法的方式则有如下3种 删除：可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数 例如：splice(0,2)会删除数组中的前两项。 2.插入：可以向指定位置插入任意数量的项，只需要提供三个参数：起始位置，0（要删除的项数）和要插入的项。如果要插0 例如：splice（2,0，”red”,”green”）会从当前数组的位置2开始插入字符串”red“和”green“。 3.替换 ：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需要指定3个参数：其实位置，要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如： splice（2,1,”red”,”green”）会删除当前数组位置2的项，然后再从位置2开始插入字符串“red”和“green”。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。 下面代码展示了上述3中方法使用splice（）方法的方式。 123456console.log(&quot;splice()方法&quot;) var peoples=[&quot;wang&quot;,&quot;tom&quot;,&quot;cat&quot;]; var removed=peoples.splice(0,1); //删除了第一项 // alert(peoples); console.log(peoples); //tom,cat 因为第一项被删除了 console.log(removed); //wang 返回的数组只包含一项 1234567removed= peoples.splice(1,0,&quot;java&quot;,&quot;python&quot;); console.log(peoples); //[&quot;tom&quot;, &quot;java&quot;, &quot;python&quot;, &quot;cat&quot;]console.log(removed); //返回的是一个空数组 因为没有删除removed=peoples.splice(1,1,&quot;c++&quot;,&quot;js&quot;);console.log(peoples); //[&quot;tom&quot;, &quot;c++&quot;, &quot;js&quot;, &quot;python&quot;, &quot;cat&quot;]console.log(removed); //[&quot;java&quot;] 这个 bitch 位置方法 indexOf（）,lastIndexOf（）不和你多bb了 直接看例子吧 打字好累啊 手都酸了 indexOf（） lastIndexOf() 两个参数：要查找的项和（可选的）表示查找起点位置的索引。 这两个方法都返回要查找的项在数组中的位置，或者没有找到的情况下返回-1.​ 12345console.log(&quot;位置方法 &quot;) var numbers = [0,1,2,3,5,8,2,1,5]; console.log(numbers.indexOf(2)); console.log(numbers.lastIndexOf(8)); 123456789101112 console.log(numbers.indexOf(2,3)); console.log(numbers.lastIndexOf(8,6)); var person={name:&quot;wang&quot;}; var people=[{name:&quot;wang&quot;}]; var morePeople=[people,&quot;jun&quot;];**我这里就不明白了 people和morePeople有什么区别** console.log(people.indexOf(person)); //-1 console.log(morePeople.indexOf(person)); //0 这里还是不不明白 迭代方法ECAMScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用于对象————影响this的值。传入这些方法中的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法： every（）：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 filter（）：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach（）：对数组中的每一项运行给定函数。这个方法没有返回值。 map（）：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some（）：对数组中的每一项运行给定函数，如果该函数对一项返回true，则返回true 在这些方法中，最相似的是every（）和some（）方法，他们都用于查询数组中的项是否满足某个条件。对every（）来说，传入的函数必须对每一项都返回true，这个方法才会返回true；否则，它就返回false。而some（）方法则是只要传入的函数对数组中的某一项返回true，就会返回true。请看下面的的例子： 1var numbers=[1,2,3,4,5,4,3,2,1]; 1234567891011var everyResult = numbers.every(function(item,index,array){ return item&gt;2;})alert(everyResult); //false 因为只有部分项符合条件var someResult=numbers.some(function(item,index,array){ return item&gt;2;})alert(someResult); //true 只要至少有一个符合就会返回true 下面来看看 filter（）方法：它利用指定的函数确定是否在返回的数组中包含某一项。例如：要返回一个所有数值都大于2的数组，可以使用如下代码： 1var numbers=[1,2,3,4,5,4,3,2,1]; 12345var filterResult = numbers.filter(function(item,index,array){ return (item&gt;2); }); alert(filterResult); //3,4,5,4,3 map（）方法也返回一个数组，而这个数组的每一项都是在原始数组中的对象上运行传入函数的结果。 例如，可以给书中的每一项乘以2，然后返回这些乘积组成的数组，如下所示： 1var numbers=[1,2,3,4,5,4,3,2,1]; 1var mapResult = numbers.map(function(item,index,array){ 1234 return (item*2);});alert(mapResult); //2,4,6,8,10,8,6,4,2 最后一个是forEach（）方法，它只是对数组中的每一项运行传入的函数。这个方法并没有返回值，本质上与使用for循环迭代数组一样。来看一个例子： 1var numbers=[1,2,3,4,5,4,3,2,1]; 123numbers.forEach(function(item,index,array){ //执行某些操作 }); 这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。支持这些迭代方法的浏览器有IE9、FireFox2+、Safari 3+、Opera 9.5+和Chrome 归并方法使用reduce（）方法可以执行求数组中所有值之和得到操作，比如： 123456var values=[1,2,3,4,5]var sum=values.reduce(function(prev,cur,index,array){ return prev+cur});alert(sum); //15 第一次执行函数，prev是1，cur是2.第二次，prev是3（1+2的结果），cur是3（数组的第三项）。以此类推，最后返回结果 reduceRight()方法的作用类似，只不过方向相反而已。来看下面这个例子 123456var values=[1,2,3,4,5]var sum=values.reduceRight(function(prev,cur,index,array){ return prev+cur});alert(sum); //15 使用reduce（）还是reduceRight()取决于从哪头开始遍历数组。除此之外，他们完全相同 Date类型 ECMAScript中的Date类型是在早期Java中的java.util.Date类型基础上构建的。为此Date类型使用UTC（国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒来保存日期。在使用这种数据储存格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的100000000年。 要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示。​ 12var now = new Date();console.log(now); Date有两个方法：Date.parse()和Date.UTC()&gt;其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异。将地区设置为美国的浏览器通常都接收下列日期格式： “月/日/年”，如 6/13/20042.** “英文月名，日，年”，如January 12，2004；** 3.** “英文星期几 英文月名 日 年 时：分：秒 时区”，如Tue 25 2004 00:00:00 GMT-0700.** 4.ISO 8601 拓展格式 YYYY-MM-DDTHH：mm：ss：sssZ（例如 2004-05-25T00:00:00:00）。只有兼容ECMAScript5的实现支持这种格式。 例如，要为2004年 5月25日创建一个日期对象，可以使用下面的代码： 1var someDate = new Date(Date.parse(&quot;May 25,2004&quot;)); 如果传入的Date.parse()方法的字符串不能表示日期，那么他会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse（）。换句话说，下面的代码与前面的例子是等价的： 1var someDate = new Date(&quot;May 25,2004&quot;); 这行代码将会得到与前面相同的日期格式 Date.UTC（）方法同样也返回表示日期的毫秒数，但它与Date.parse（）在构建时使用不同的信息。Date.UTC（）得到参数分别是年份，基于0的月份（0开始，一月是0），月中的哪一天（1-31），小时数（0-23），分钟，秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必须的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统为0.一下是两个使用Date，UTC（）方法的例子：1//GMT时间2000年1月1日午夜零点 1var y2k = new Date(Date.UTC(2000,0)); 1//GMT时间2005年5月5日下午5:55:55 1var allFives = new Date(Date.UTC(2005,4,5,17,55,55)); 1//也可以重写 1//GMT时间2000年1月1日午夜零点 1var y2k = new Date(2000,0); 1//GMT时间2005年5月5日下午5:55:55 1var allFives = new Date(2005,4,5,17,55,55); ECMAScript5中添加了Date.now（）方，返回表示调用这个方法时的日期和事件的毫秒数。这个方法简化了使用Date对象分析代码的工作。例如： 1//取得开始时间 1234567891011 var start =Date.now(); function doSomething(){ for(var i=0;i&lt;100;i++){ console.log(&quot;hello world!&quot;); } }; doSomething();//取得结束时间 var stop = Date.now(); var result = stop - start; console.log(&quot;调用这个函数输出 hello world！ 花了：&quot;+result+&quot;豪秒&quot;); ​ 支持Date.now（）方法的浏览器包括IE9+，Firefox3+，Safari3+，Opera10.5和Chrome。在不支持他的浏览器中，使用+操作符获取Date对象的时间戳，也可以达到同样的目的。1//取得开始时间 1var start =+new Date(); 1234567//调用函数doSomethin();//取得停止时间var stop= +new Date();result = stop - start; Date类型也重写了toLocaleString和toString（）和valueOf（）方法；前两种方法在不同的浏览器中返回的日期和事件格式可谓大相径庭。事实上，toLOcaleString和toString方法的差别尽在调试代码比较有用，而在现实日期和时间没有什么价值。至于Date类型的valueOf（）方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以方便使用比较操作符（大于或者小于）来比较日期值。请看下面的例子。 12345var date1 = new Date(2007,0,1);var date2 = new Date(2007,1,1);console.log(date1&lt;date2); // trueconsole.log(date1&gt;date2); // false 日期格式化的方法Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下： 1var time=date1.toDateString(); //用于特定的格式显示 星期几、月、日和年 1console.log(time); //Mon Jan 01 2007 1time=date1.toTimeString(); //以特定于实现的格式显示 时、分、秒和时区 1console.log(time); //00:00:00 GMT+0800 (中国标准时间) 1time=date1.toLocaleDateString(); //以特定于地区的格式显示星期几、月、日和年 1console.log(time); //2007/1/1 1time=date1.toLocaleTimeString(); //以特定于实现的格式显示 时、分、秒 1console.log(time); //上午12:00:00 1time=date1.toUTCString(); //以特定于实现的格式完整的UTC日期 1console.log(time); //Sun, 31 Dec 2006 16:00:00 GMT 与toLocaleString（）和toString（）方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面显示一致的日期时间。 除了前面介绍的方法之外，还有一个名叫toGMTString（）的方法，这是一个与toUTCString（）等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写代码一律用toUTCString（）方法。 日期/时间组件方法","link":"/2020/01/14/ES5%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"},{"title":"hexo+github搭建个人博客","text":"第一次搭建个人博客（hexo、node）原文地址https://www.simon96.online/2018/10/12/hexo-tutorial/ 环境准备 Node.js 下载，并安装。详细步骤：https://www.simon96.online/2018/11/10/hexo-env/ Git 下载，并安装。详细步骤：https://www.simon96.online/2018/11/10/hexo-env/ 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，在路径下，会产生这些文件和文件夹： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 路径为&lt;folder&gt;\\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 路径为&lt;folder&gt;\\themes\\&lt;主题文件夹&gt;\\_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 浏览器访问网址： http://localhost:4000/ 这样你的Hexo博客已经搭建在本地。 放到github服务器上 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 12$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 12$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 详见：https://github.com/search?q=hexo-theme 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt; 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\\themes*\\layout_partials\\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1234567body{ background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;} 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 12345678@font-face { font-family: Zitiming; src: url('/fonts/Zitiming.ttf');}.site-title { font-size: 40px !important; font-family: 'Zitiming' !important;} 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 网站标题栏背景颜色打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 123.site-meta { background: $blue; //修改为自己喜欢的颜色} 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1234567// 鼠标样式 * { cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important } :active { cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important } 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 ``之前插入代码： 12345678910&lt;script&gt; (function(){ if('{{ page.password }}'){ if (prompt('请输入密码') !== '{{ page.password }}'){ alert('密码错误'); history.back(); } } })();&lt;/script&gt; 写文章时加上password: *： 12345---title: 2018date: 2018-10-25 16:10:03password: 123456--- 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 在\\themes\\*\\layout\\_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 静态资源压缩在站点目录下： 1$ npm install gulp -g 安装gulp插件： 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩css文件gulp.task('minify-css', function() { return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));});// 压缩html文件gulp.task('minify-html', function() { return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin({ removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, })) .pipe(gulp.dest('./public'))});// 压缩js文件gulp.task('minify-js', function() { return gulp.src(['./public/**/.js','!./public/js/**/*min.js']) .pipe(uglify()) .pipe(gulp.dest('./public'));});// 压缩 public/demo 目录内图片gulp.task('minify-images', function() { gulp.src('./public/demo/**/*.*') .pipe(imagemin({ optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 })) .pipe(gulp.dest('./public/uploads'));});// 默认任务gulp.task('default', [ 'minify-html','minify-css','minify-js','minify-images']); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 123hexo ggulphexo d 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 1permalink: :category/:title/ 博文置顶 安装插件 $ npm uninstall hexo-generator-index –save$ npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 12345---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 12345{% if post.top %} &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;{% endif %} 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 12345678// 主页文章添加阴影效果.post { margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);} 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 12345# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 12$ cd &lt;站点目录&gt;$ hexo new page categories 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 1{% include '_custom/google_ad.swig' %} 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 123456{% block content %} &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; {{ post_template.render(page) }} {% include '_custom/google_ad.swig' %} &lt;/div&gt;{% endblock %} 等待审核通过。如果失败，可再次申请。 添加萌萌哒（进入二次元） 安装插件 1npm install --save hexo-helper-live2d 复制你喜欢的模型名字： hijiki Unitychan haruto hibiki z16 wanko tsumiki shizuku nito nipsilon nietzche nico ni-j miku haru Gantzert_ Felixander Epsilon2.1 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 12 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071721. 建配置文件 4.1. 在站点目录下建文件夹`live2d_models`， 4.2. 再在`live2d_models`下建文件夹`&lt;你喜欢的模型名字&gt;`, 4.3. 再在`&lt;你喜欢的模型名字&gt;`下建json文件：&lt;你喜欢的模型名字&gt;.model.json2. 安装模型。在命令行（即Git Bash）运行以下命令即可： &gt; npm install --save live2d-widget-model-&lt;你喜欢的模型名字&gt;3. 在命令行（即Git Bash）运行以下命令， 在`http://127.0.0.1:4000/`查看测试结果: &gt; hexo clean &amp;&amp; hexo g &amp;&amp; hexo s### 插件配置 以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。#### 评论系统| | 推荐指数 | 优点 | 缺点 || ---------------------------------------- | ---- | ------------------ | ------------ || [Valine](https://valine.js.org/) | 4 | 每天30000条评论，10GB的储存 | 作者评论无标识 || [来必力/livere](https://livere.com/) | 4 | 多种账号登录 | 评论无法导出 || [畅言](http://changyan.kuaizhan.com/) | 3 | 美观 | 必须备案域名 || [gitment](https://github.com/imsun/gitment) | 3 | 简洁 | 只能登陆github评论 || Disqus | 1 | | 需要翻*墙 |##### Valine 1.1. 获取APP ID 和 APP Key 请先登录或注册 [LeanCloud](https://leancloud.cn/), 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的`设置`&gt;`应用Key`，然后就能看到你的`APP ID`和`APP Key`了。 1.2. 填写APP ID 和 APP Key到主题配置文件`_config.yml` 1.3. 运行`hexo g&amp;&amp;hexo d`推送到博客。##### 来必力/livere 2.1. 登陆 [来必力](https://livere.com/) 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件`_config.yml`##### 畅言 3.1.获取APP ID 和 APP Key 请先登录或注册 [畅言](http://changyan.kuaizhan.com/), 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的`APP ID`和`APP Key`了。 3.2. 填写APP ID 和 APP Key到主题配置文件`_config.yml` 3.3. 运行`hexo g&amp;&amp;hexo d`推送到博客。##### gitment 4.1. 安装插件：&gt; npm i --save gitment 4.2. 申请应用 在[New OAuth App](https://github.com/settings/applications/new)为你的博客应用一个密钥: Application name:随便写 Homepage URL:这个也可以随意写,就写你的博客地址就行 Application description:描述,也可以随意写 Authorization callback URL:这个必须写你的博客地址 12344.3. 配置编辑主题配置文件`themes/*/_config.yml`: GitmentIntroduction: https://imsun.net/posts/gitment-introduction/ gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide ‘Powered by …’ on footer, and more language: # Force language, or auto switch by theme github_user: {you github user id} github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: {刚才申请的ClientID} client_secret: {刚才申请的Client Secret} proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro 1234##### Disqus 编辑 主题配置文件`themes/*/_config.yml`， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 disqus: enable: false shortname: count: true 12345678910111213141516#### 数据统计与分析| | 推荐指数 | 优点 | 缺点 || ---------------------------------------- | ---- | ----------------------- | ---- || [不蒜子](http://ibruce.info/2015/04/04/busuanzi/) | 4 | 可直接将访问次数显示在您在网页上（也可不显示） | 只计数 || 百度统计 | 3 | | 收录慢 |##### 不蒜子 编辑 主题配置文件 `themes/*/_config.yml`中的`busuanzi_count`的配置项即可。- 当`enable: true`时，代表开启全局开关。- 若`site_uv`（本站访客数）、`site_pv`（本站访客数）、`page_pv`（本文总阅读量）的值均为`false`时，不蒜子仅作记录而不会在页面上显示。 注意： 不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！ 123456 解决办法：1. 找到主题调用不蒜子的swig文件。一般在”\\themes*\\layout_third-party\\analytics\\busuanzi-counter.swig”2. 更改域名 把原有的： 域名改一下即可： 12 12 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图： 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享 编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 12# 百度分享服务baidushare: true need-more-share2 编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 12needmoreshare2: enable: true 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search 添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 12 121. 编辑 站点配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 12 12 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 12 12","link":"/2019/12/23/hexo/"},{"title":"我读Vue源码-1","text":"​ 心态有点崩，刚刚写了一个小时居然没有保存，然后不小心关电脑了，前面写的一大堆废话都没了。不管了先从现在看的写，前面写的有空的话再不回来。多按按 ctrl+s ，别总是按 ctrl+a ctrl+c ctrl+v ​ 第二天过来补充，没想到昨天状态还不错，读到了快1200行，工具函数读完之后就到了响应式的实现了，响应式的实现主要是发布监听来实现，通过拦截传入的数据，赋值到this上面，然后通过 Object.defineProperty()来设置属性的 getter、setter 方法，在设置了 __ob__的值上面会在数据发生变化时通知 订阅 更新。当然还有特殊的对象比如数组，可以拦截 sort splice push unshift 等这些会改变数组的方法。 现在开始之前说过在710行出现 uid 之前的代码都是一些变量和工具函数的定义。 1234567891011121314151617181920212223242526272829303132333435363738394041 // 阻止修改1现有属性的特性和值，也不能添加新的属性 var emptyObject = Object.freeze({}); //判断一个变量的值是不是 undefined或者是null function isUndef (v) { return v === undefined || v === null }//判断一个变量的值是否定义了，也就是不为undefine和null function isDef (v) { return v !== undefined &amp;&amp; v !== null } //判断一个布尔值真假，也就是是不是真的等于 true //而不是 == 会发生隐式转化后为true function isTrue (v) { return v === true }//和上面是一样的 function isFalse (v) { return v === false } // 判断是否为原始值// ES5原始值有 string number boolean// ES6新增了 symbol function isPrimitive (value) { return ( typeof value === 'string' || typeof value === 'number' || // $flow-disable-line typeof value === 'symbol' || typeof value === 'boolean' ) } //判断是原始值还是对象，当我们知道值是//json 兼容型 function isObject (obj) { return obj !== null &amp;&amp; typeof obj === 'object' } 判断一个值的原始类型字符串，利用Objet原型上的 toString() 方法,因为Object下面各个对象都重写了自己的 toString() 方法，而Object上的就是返回原始类型的字符串的 12345var _toString = Object.prototype.toString; function toRawType (value) { return _toString.call(value).slice(8, -1)} 判断一个值是不是真的JavaScript对象，比如 node节点 typeof 返回的是 object,但是严格上来讲是 NodeList ，而不是我们认为的 json对象那种 123function isPlainObject (obj) { return _toString.call(obj) === '[object Object]' } 判断是不是一个合格的数组下标 1234function isValidArrayIndex (val) { var n = parseFloat(String(val)); return n &gt;= 0 &amp;&amp; Math.floor(n) === n &amp;&amp; isFinite(val) } 判断是不是一个 Promise 值 1234567function isPromise (val) { return ( isDef(val) &amp;&amp; typeof val.then === 'function' &amp;&amp; typeof val.catch === 'function' )} 把一个值转化成实际所呈现出来的字符串（不是很能理解） 12345678function toString (val) { return val == null //null或者undefined就返回空字符串而不是'null'、'undefined' ? '' :Array.isArray(val) || （isPlainObject(val) &amp;&amp; val.toString === _toString） //是一个数组或者是原始对象的话就可以 ? JSON.stringify(val, null, 2) : String(val)} 将字符串转化为数字，如果转化失败，也就是 NaN，那么就直接返回字符串 1234function toNumber (val) { var n = parseFloat(val); return isNaN(n) ? val : n} 把传入的字符串创建一个 map，返回一个函数可以检查 key 是否存在于map当中，第二个参数来决定是否区分大小写 12345678910function makeMap (str, expectLowercase) { var map = Object.create(null);//创建一个真的空对象 var list = str.split(','); for(var i = 0; i&lt;list.length; i++) { map[list[i]] = true } return expectLowercase ? function (val) { return map[val.toLowerCase()]} : function (val) { return map[val]}} 移除数组中的一项，当你不知道该项在数组中的索引的时候 12345678function remove (arr, item) { if(arr.length) { var index = arr.indexOf(item); if(index &gt; -1) { return arr.splice(index,1) } }} 检查一个对象是否自己有这个 属性 1234var hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn (obj, key) { return hasOwnProperty.call(obj,key);} 返回一个函数并该函数返回一个已经缓存的字符串，也就是结果吧 利用了闭包将已经计算好了的结果缓存在一个 catch 对象 在我们重复调用函数但是可能这些值我们已经计算过了，就直接返回缓存中存了的 在下面有些方法中会使用到 1234567function catched (fn) { var catch = Object.create(null); return (function catchedFn (str) { var hit = catch[str]; return hit || catch[str] = fn(str); })} 把用连字符分割字符串变成驼峰命名，比如 v-model&gt;vModel 将首字母变成大写 把驼峰命名字符串变成连字符链接 比如 aBc &gt; a-bc 1234567891011121314151617181920var camelizeRE = /-(\\w)/g;var camelize = cached(function (str) { return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })});var capitalize = cached(function (str) { return str.charAt(0).toUpperCase() + str.slice(1)});//举个例子，如果我在下面var str = capitalize('javascript');//会将我传入的字符串 'javascript'变成'Javascript'//同时由于我已经转化过一次了，将它存在缓存当中，catch也就是闭包所引用的var str1 = capitalize('javascript')//z这时候就是直接从缓存当中获取了var hyphenateRE = /\\B([A-Z])/g;var hyphenate = cached(function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase()}); 这是一个 bind polyfill,虽然大部分可以说是所有的浏览器都支持 bind，但是还是不排除有憨憨使用的浏览器太感人了，算是 优雅降级吧。不得不说 Vue的开发者想的太周到了，内力雄厚啊。 12345678910111213141516171819202122//绑定函数，并且改变上下文function polyfillBind (fn, ctx) { function boundFn (a) { var l = arguments.length; return l ? l&gt;1 ? fn.apply(ctx,arguments) : fn.call(ctx,a) : fn.call(ctx) } boundFn._length = fn.length; return boundFn}//原始的bindfunction nativeBind （fn,ctx) { return fn.bind(ctx);}//判断是否支持bindvar bind = Function.prototype.bind ? nativeBind : polyfillBind 把一个类数组变成一个数组 当然也可以使用 Array.prototype.slice.call(list) ，如果不需要项下面这样可能会只要部分 123456789function toArray (list,start) { start = start || 0; var i = list.length - start; var ret = new Array(i); while (i--) { ret[i] = list[i+start]; } return ret} 把属性混入到目标属性 123456function extend (to,_from) { for(var key in _from) { to[key] = _from[key]; } return to} 合并数组里面的对象到一个对象里面，是浅拷贝 123456789function toObject (arr) { var res = {}; for (var i = 0; i &lt; arr.length; i++) { if(arr[i]) { extend(res,arr[i]); } } return res} 下面这几个函数就比较让人摸不着头脑，不知道是干什么用的 123456789101112131415161718/** * Perform no operation. * Stubbing args to make Flow happy without leaving useless transpiled code * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/). */ function noop (a, b, c) {} /** * Always return false. */ var no = function (a, b, c) { return false; }; /* eslint-enable no-unused-vars */ /** * Return the same value. */ var identity = function (_) { return _; }; 生成一个字符串，用 , 连接起来，用来连接数组对象中的 stacticKeys key值 ， [{stacticKeys:1},{stacticKeys:2},{stacticKeys:3}]变成一个字符串 1,2，3‘ 还不知道使用来干啥的 12345function genStaticKeys (module) { return module.reduce(function (keys, m) { return keys.concat(m.staticKeys || []) }, []).join(',')} 判断两个值是不是 宽松的 相等，如果是两个不同的对象，虽然引用不同，==判断也是不相等的。但是他们看起来可能会一样 比如 var a = {a:'a'} var b = {a:'a'},还比如两个数组长度相等，且每一项相等 1234567891011121314151617181920212223242526272829303132333435363738function looseEqual (a,b) { if (a === b) return true; var isObjectA = isObject(A); var isObjectB = isObject(B); if(isObjectA &amp;&amp; isObjectB) { //如果都是对象进入这一步 try{ var isArrayA = Array.isArray(a); var isArrayB = Array.isArray(b); if (isArrayA &amp;&amp; isArrayB) { //两个都是数组 return a.length === b.length &amp;&amp; b.every(function (e, i) { return looseEqual(e,a[i]);//长度相同，且递归判断每一项是否相等 }) }else if (a instance of Date &amp;&amp; b instanceof Date) { return a.getTime() === b.getTime() //还可以判断两个date对象的时间是不是相等的 }else if(!isArrayA &amp;&amp; !isArrayB){ //两个都不是数组，但是是对象 var keysA = Object.keys(a); var keysB = Object.keys(b); return keysA.length === keysB.length &amp;&amp; keysB.every(function (key) { return looseEqual(a[key],b[key]); //a b 的keys长度相等，递归判断两者属性是否相等 }) } else { return false } } catch(e) { return false; } }else if(!isObjectA &amp;&amp; !isObjectB){ return String(a) === String(b); }else { return false }} 判断数组中是否有一个值与传入的值相等,并返回第一个值的索引 12345678function looseIndexOf (arr,val) { for (var i = 0; i&lt;arr.length; i++) { if(looseEqual(arr[i], val)) { return i; } } return -1;} 确保这个函数只被调用一次,闭包函数 123456789function once (fn) { var called = false; return function () { if(!called) { called = true; fn.apply(this, arguments) } }} 下面一些都是一些标识符和配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//ssr标记属性，ssr就是服务端渲染var SSR_ATTR = 'data-server-rendered'; // 组件指令 定义指令 、 过滤器指令 var ASSET_TYPES = [ 'component', 'directive', 'filter' ]; var LIFECYCLE_HOOKS = [ 'beforeCreate', //生命周期，开始实例化 vue 指令 'created', //生命周期， 结束实例化 vue 指令 'beforeMount', //生命周期，开始渲染虚拟 dom，挂载 event 事件 'mounted', //生命周期，渲染虚拟dom，挂载 event结束了 'beforeUpdate', //生命周期，开始更新view数据 指令 'updated', //生命周期，结束更新view数据 指令 'beforeDestroy', //生命周期，开始销毁 new 出来的实例 'destroyed', //生命周期，结束销毁实例 'activated', //keep-alive 组件激活时使用 'deactivated', //keep-alive 组件停用时调用 'errorCaptured',// 具有此钩子的组件捕获其子组件树（不包括其自身）中的所有错误（不包括在异步回调中调用的那些） 'serverPrefetch' // 暂时不清楚 ]; /* */ var config = ({ /** * Option merge strategies (used in core/util/options) */ // $flow-disable-line //合并对象策略 optionMergeStrategies: Object.create(null), /** * Whether to suppress warnings. */ silent: false, /** * Show production mode tip message on boot? */ productionTip: &quot;development&quot; !== 'production', /** * Whether to enable devtools */ devtools: &quot;development&quot; !== 'production', /** * Whether to record perf */ performance: false, /** * Error handler for watcher errors */ errorHandler: null, /** * Warn handler for watcher warns */ warnHandler: null, /** * Ignore certain custom elements */ ignoredElements: [], /** * Custom user key aliases for v-on */ // $flow-disable-line keyCodes: Object.create(null), /** * Check if a tag is reserved so that it cannot be registered as a * component. This is platform-dependent and may be overwritten. */ isReservedTag: no, /** * Check if an attribute is reserved so that it cannot be used as a component * prop. This is platform-dependent and may be overwritten. */ isReservedAttr: no, /** * Check if a tag is an unknown element. * Platform-dependent. */ isUnknownElement: no, /** * Get the namespace of an element */ getTagNamespace: noop, /** * Parse the real tag name for the specific platform. */ parsePlatformTagName: identity, /** * Check if an attribute must be bound using property, e.g. value * Platform-dependent. */ mustUseProp: no, /** * Perform updates asynchronously. Intended to be used by Vue Test Utils * This will significantly reduce performance if set to false. */ async: true, /** * Exposed for legacy reasons */ _lifecycleHooks: LIFECYCLE_HOOKS }); 检查一个字符串是否以$或者_开头 1234function isReserved (str) { var c = (str + '').charCodeAt(0); return c === 0x24 || c === 0x5F} 定义对象的属性 12345678function def (obj, key, val, enumerable) { Object.defineProperty(obj,key,{ value: val, enumerable: !!enumerable, writable: true, configurable: true })} 匹配不是 数字字母下划线 $符号 开头的（正则表达式还不是很会，下次再来看） 1234567891011121314var bailRE = new RegExp((&quot;[^&quot; + (unicodeRegExp.source) + &quot;.$_\\\\d]&quot;)); function parsePath (path) { if (bailRE.test(path)) { return } var segments = path.split('.'); return function (obj) { for (var i = 0; i &lt; segments.length; i++) { if (!obj) { return } obj = obj[segments[i]]; } return obj } } 我们能不能用 __proto__ 1var hasProto = '__proto__' in {}; 判断浏览器和设备 123456789101112131415var inBrowser = typeof window !== undefined //判断是不是浏览器var inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platform; var weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase(); var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase(); var isIE = UA &amp;&amp; /msie|trident/.test(UA); var isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0; var isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0; var isAndroid = (UA &amp;&amp; UA.indexOf('android') &gt; 0) || (weexPlatform === 'android'); var isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios'); var isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge; var isPhantomJS = UA &amp;&amp; /phantomjs/.test(UA); var isFF = UA &amp;&amp; UA.match(/firefox\\/(\\d+)/); // Firefox has a &quot;watch&quot; function on Object.prototype... var nativeWatch = ({}).watch; 兼容火狐浏览器的写法 （还是看不懂） 12345678910111213var supportsPassive = false;if (inBrowser) { try { var opts = {}; Object.defineProperty(opts, 'passive', ({ get: function get () { /* istanbul ignore next */ supportsPassive = true; } })); // https://github.com/facebook/flow/issues/285 window.addEventListener('test-passive', null, opts); } catch (e) {}} #####这里好像是设置服务器渲染的，也还是不太懂 123456789101112131415161718192021222324// this needs to be lazy-evaled because vue may be required before// vue-server-renderer can set VUE_ENV //vue 服务器渲染 可以设置 VUE_ENV var _isServer;//判断是不是node 服务器环境 var isServerRendering = function () { if (_isServer === undefined) { /* istanbul ignore if */ //如果不是浏览器 并且global 对象存在，那么有可能是node 脚本 if (!inBrowser &amp;&amp; typeof global !== 'undefined') { // // detect presence of vue-server-renderer and avoid // Webpack shimming the process //_isServer 设置是服务器渲染 _isServer = global['process'].env.VUE_ENV === 'server'; } else { _isServer = false; } } return _isServer }; // detect devtools 检测工具 var devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__; 判断该函数是不是系统内置函数 判断是否支持 Symbol 数据类型 123456789function isNative (Ctor) { return typeof Ctor === 'function' &amp;&amp; /native code/.test(Ctor.toString()) } var hasSymbol = typeof Symbol !== 'undefined' &amp;&amp; isNative(Symbol) &amp;&amp; typeof Reflect !== 'undefined' &amp;&amp; isNative(Reflect.ownKeys); // Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 判断是否有ES6的 Set数据结构，如果没有自己写一个 123456789101112131415161718192021var _Set;if( typeof Set !== 'undefined' &amp;&amp; isNative(Set)) { _Set = Set;} else {//a non-standard Set polyfill that only works with primitive keys. 非标准的 _Set = (function () { function Set () { this.set = Object.create(null); } Set.prototype.has = function has (key) { return this.set[key] === true }; Set.prototype.add = function add (key) { this.set[key] = true; }; Set.prototype.clear = function clear () { this.set = Object.create(null); }; return Set })()} 一直到这里似乎都和Vue 本身没啥关系，这些都是工具函数，方便以后的使用，jQuery也有好多类似的方法。 ​","link":"/2020/01/31/%E6%88%91%E8%AF%BBVue%E6%BA%90%E7%A0%81-1/"},{"title":"浏览器对象-BOM","text":"浏览器对象-BOM​ 如果说，ECMAScript 是 JavaScript的核心，那么想要在浏览器中使用JavaScript，BOM无疑才是真正的核心BOM提供了很多对象供浏览器使用，这些都与页面内容无关， 下面是BOM主要内容 理解window对象——BOM的核心 控制窗口、框架和弹出窗口 利用 location 对象中的页面信息 使用 navigator 对象了解浏览器 1 window对象​ BOM的核心是 window，他表示一个浏览器实例。在浏览器当中，window对象有双重角色，它既是通过 JavaScript 访问浏览器的一个接口，有是 ECMAScript 规定的Global对象，这意味着在网页中定义的任何一个对象，变量，函数都可以以window对象作为Global访问 1.1 全局作用域​ 所有在全局作用域中声明的变量、函数，最后都会变成window 对象的属性和方法 12345678var a = 12;function fn1 () { alert(this.a)}alert(window.a) //12window.fn1() //12fn1() //12 ​ 很明显我们在全局作用域定义的变量和函数最后都会归于window 对象下。于是可以通过window.a和window.fn1()来访问和调用在全局作用域下定义的变量 a和函数 fn1，但是在全局作用域下定义变量与在 window对象下直接定义属性还是有那么一点点区别的。 ​ 全局变量下定义的变量不能通过 delete 操作符删除，而在 window 下直接定义的属性可以。例如： 1234567891011var age = 22;window.color = 'red'//在IE&lt;9 时抛出错误，在其他所有浏览器都返回 falsedelete window.age//在IE&lt;9 时抛出错误，在其他所有浏览器都返回 truedelete window.coloralert(window.age) //22alert(window.color) //undefined ​ 这是因为我们使用 var 语句声明的 age 属性在window 中有一个属性名为 [[Configurable]]的特性，这个特性的值被设置为了false，因此这样直接在全局定义的属性是不可以通过 delete 操作符删除掉，IE8及以下不管属性是怎么创建的都会抛出错误。IE问题真的是多 1.2 窗口关系及框架​ 如果一个页面中包含框架，则每个框架都有一个自己的window对象，并且保存在 frames集合中。在 frames集合中可以通过索引访问相应的 window对象，每个window对象都有一个name属性，其中包含了框架的名称。 ​ top对象始终指向最外层框架，也就是浏览器。与top对象对应的是parent 对象，顾名思义，parent对象始终指向当前框架的直接上层框架。在某些情况下 parent有可能等于top；但在没有框架的时候，parent一定等于top，这个应该很好理解。 1.3 窗口位置​ screenLeft、screenTop 或者 screenX、screenY返回的是窗口相对于屏幕左边和上边的位置。浏览器窗口紧贴屏幕最上方的时候，screenTop或者 screenY ，Firefox、Chrome、Safari返回的是浏览器工具栏也就是整个浏览器窗口相对于屏幕上方的位置也就是0；而不是像IE和Opera一样返回的是页面可见区域相对屏幕上方的精确距离。 ​ 更特别的一点是 ，Firefox、Chrome、Safari始终返回的是每个页面框架的 top.screenLeft和screenTop的值，就算框架设置了外边距的情况返回的值也是相同的。而IE和Opera则会返回框架相对于屏幕精确的值。 ​ 虽然我们可以使用 moveTo 和 moveBy 两个函数将窗口移到一个精确地值，这两个方法都接收两个参数，一个是新位置的x和y的坐标，一个是在水平和垂直方向上移动的距离。 123window.moveTo(0,0) //将窗口移到左上角window.moveBy(200,300) //将窗口水平移动200px，垂直移动300px ​ 需要注意的是这个两个方法都有可能被浏览器禁用了，在Opera和IE&gt;7默认就是禁用的。 1.3 窗口的大小​ 跨浏览器确认一个窗口的大小可不是一件简单的事。IE9+，Firefox、Safari、Opera和Chrome均提供了四个属性： innerWidth innerHeight outWidth和 outHeight 。在不同浏览器有不同的标准，这里就不细说了。 ​ 虽然无法确认浏览器本身窗口大小，但是却可以获得页面视口大小。 123456789101112var pageHeight = window.innerHeight, pageWidth = window.innerWidth if(typeof pageWidth != 'number') { if(document.compatModel) { pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; }else{ pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight } } ​ 先检查 pageWidth 和 pageHeight是不是数值，如果不是的话，则通过检查 document.compatModel 来确认页面是否处于标准模式，如果是则使用 document.documentElement.clientWidth ；否则使用 document.body.clientWidth。 对于移动设备window.innerHeight始终保存着可见视口区域的大小。移动IE不支持这个，但是可以通过 document.documentElement.clientHeight 提供相同的信息。随着页面的缩放这些信息也会改变。 ​ 和移动窗口的两个方法 moveTo moveBy 类似的两个方法0 resizeTo resizeBy，这两个方法可以调整浏览器的大小。但是同样也可能会被浏览器禁用。 1.4 导航和打开窗口​ 使用 window.open() 可以导航到一个窗口也可以打开一个窗口这个方法可以接收四个参数值：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需要传递第一个值，最后一个值只在不打开新窗口的情况下使用。 ​ 如果为 window.open() 传递了第二个参数，而且参数是已有窗口或框架名称，那么就会在具有该名称的窗口或框架下加载 第一个参数指定的 URL。 12//等同于 &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt;window.open(&quot;http://www.baidu.com&quot;,&quot;topFrame&quot;) ​ 如果有一个名叫“topFrame” 的窗口或框架就会在该窗口下加载URL；否则就会创建一个新的窗口并将其命名为“topFrame”。此外第二个参数也可以是下列任何一个特殊的窗口名称： _self -parent _top _blank 弹出一个窗口​ 如果 window.open() 第二个参数并不是一个以及存在窗口或者框架，那么该方法就会根据第三个参数 传入的字符串创建一个新窗口或标签页。如果没有传入第三个参数，浏览器就只好自己根据默认配置（工具栏、地址栏、状态栏）打开一个新的窗口或者标签页（根据浏览器设置）。在不打开新窗口的时候回忽略第三个参数。 下面是第三个参数的配置说明： fullscreen 可以去yes或者no，表示是否最大化，仅限IE height 表示高度。不能小于100 left 数值，表示到左边的距离。不能是负值 location yes或者no，表示是否在浏览器窗口显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏有可能会被隐藏也有可能会被禁用。（取决于不同浏览器） menubar yes或no 表示是否在浏览器窗口显示菜单栏。默认值为no resizable yes或no 表示是否可以拖动浏览器框来改变窗口大小，默认为no scrollbar yes或no 表示如果内容在视口显示不下，是否允许滚动。默认值为 no status yes或no 表示是否在浏览器窗口显示状态栏。 默认值为no toolbar yes或no 表示是否在浏览器窗口显示工具栏。 默认值为no top 同样不能为负值 width 同样不能小于100 1234567var myBaidu = window.open(&quot;http://www.baidu.com&quot;,&quot;myBaidu&quot;,&quot;height=400,width=400,top=20,left=20,resizable=no&quot;)myBaidu.close() //可以在打开窗口的地方关闭，但也只能是打开的关闭被打开的alert(myBaidu.closed) //true alert(myBaidu.opener === window) //true 2. location对象location 对象是最有用的 BOM 对象之一，它提供了当前窗口加载文档有关的信息，还提供了一些导航功能。location既是document的对象也是window的对象；换句话说 document.locatation和window.location引用的是同一个对象。下表列出了 location 对象的所有属性。（省略了 每个属性前面的location前缀） hash “#contents” 返回URL中的hash（#后面跟零或多个字符），不包含散列则返回空字符串 host ”wxww.xxx.com：8080“ 返回服务器名和端口号（如果有的话） hostname “wxww.xxx.com” 返回不带端口号的服务器名 href “httxp://wxww.xxx.com:80” 返回当前加载页面完整的URL，等于location.toString()的返回值 pathname “/static/img” 返回URL中的目录和文件名 port 如果有的话返回端口号，没有的话则返回空字符串 protocol “http:” 返回页面使用的协议。通常都是http或https search “？q=1235” 返回URL的查询字符串，通常都是以？开头 2.1 查询字符串searchlocation.search返回的是一个以？开头的查询字符串，如果有多个查询参数的话还会用&amp;连接，但我们却不方便直接访问每个查询字符的参数。可以自己写一个函数以便解析 1234567891011121314function getQueryObj () { //取得查询字符串并去掉开头的？ var qs = location.search?location.search.substring(1):&quot;&quot;; var obj = {}; let items = qs.length ? qs.spilt(&quot;&amp;&quot;) : []; items.forEach( function (item) { //在这里取到的字符串很有可能是被编码过的 let name = decodeURLCoponent(item.split(&quot;=&quot;)[0]); let value = decodeURLCoponent(item.split(&quot;=&quot;)[1]); obj[name] = value; } ); return obj;} 2.2 位置操作使用location对象可以改变浏览器位置，location.assign(url)可以打开新的URL并在浏览器的历史记录中添加一条新的记录。如果是直接将location的href的值设置为了别的也会调用 assign（） 方法。 1234//这几种写法是等价的window.location = 'www.xxx.baidu.com'document.location = 'www.baidu.com'location.assign('www.baidu.com') ​ 在IE8、Firefox1、Safari2+，Opera9+和Chrome中，修改hash的值会在浏览器的历史记录中添加一条新的记录，在IE早期版本， hash 属性不会在用户单击‘后退’或者‘前进’ 按钮时被更新，而只会在用户点击了包含hash的URL时才会更新。 ​ 当通过上述任何一种方式修改URL之后浏览器都会生成一条新的历史记录，因此用户点击按钮“后退”都会导航到前面一个页面。要禁用这种行为可以使用 replace 方法。这个方法只接受一个参数，即要导航去的URL；结果虽然会导致浏览的位置发生改变，但是不会再历史记录中生成新的记录。再调用 replace（） 方法之后，用户不能再回到之前的页面。 12location.replace('www.baidu.com')//用户是无法通过点返回的 与位置有关的最后一个方法是reload(),作用是重新加载页面。如果调用reload()时不传入任何参数，页面就会以最有效的方式重新加载。也就是说如果页面上次请求以来没有发生过改变，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则可以在参数中传入一个true 12location.reload() //重新加载（有可能从缓存中加载）location.reload(true) //重新加载（从服务器重新加载） 3. navigator对象​ 最早由 Netscape2.0引入 navigator对象，现在已经成为识别客户端浏览器的事实标准。 3.1 插件检测检测浏览器中是否安装了特定的插件是一种最常见的检测流程。对于IE浏览器，可以使用plugins数组来达到这个目的。该数组的每一项都包含下列属性。 name :插件的名称。 description ：插件的描述 filename ：插件的文件名。 length ：插件所处理的MIME 类型数量 ​ 一般来说，name属性中会包含检测插件必须的所有信息，但是有的时候也不全是如此。在检测插件是需要像下面这样循环迭代每一个插件名并将name和给定的插件名进行对比 123456789101112//插件检测（在IE中无效）function hasPlugin (name) { name = name.toLowerCase(); for(let i = 0; i &lt; navigator.plugins.length; i++) { if(navigator.plugins[i].name.toLowerCase.indexOf(name) &gt; -1){ return true } } return false;}alert(hasPlugin(&quot;flash&quot;)) 4. screen对象​ JavaScript有几个对象在编程中用处不大，而screen 对象就是其中之一。screen对象基本上就是用来表示客户端能力，其中包含浏览器窗口外部的显示器信息。 1window.resizeTo(window.availWidth,window.availHeight) ​ 但是大部分浏览器都会默认禁用 调整浏览器大小的能力，所以上面的代码很可能没有效果 5. history 对象​ history 对象保存着用户上网的历史记录，从窗口被打开的那一刻起。因为history是window对象的属性，因此每个浏览器窗口、每个标签乃至每个框架，都有自己特定的history对象与特定的window对象关联。出于安全考虑，开发人员无法获得用户已经浏览过的URL。不过借用用户访问过的列表，同样可以在不知道URL的情况下前进后退。 ​ 使用 go（） 方法可以再用户的历史记录中任意跳转，这个方法接收一个参数值，即向前跳转或者先后跳转的整数值，正数表示向前跳转，负数表示向后跳转。类似于浏览器的前进后退。 12history.go(1) //前进一页history.go(-2) //后退两页 ​ 也可以给 go()方法传入一个字符串参数，此时浏览器会跳转到历史记录中包含这个字符串最近的一个位置，有可能前进也有可能后退。如果历史记录中不包含这个字符串，那么就会什么都不做。 12history.go('baidu.com')//跳转到最近的'baidu.com' ​ 另外还可以用两个简写的方法back()和foward()来代替go()。顾名思义可以前进后退，可读性更强点。 ​ 除了上述几个方法之外history还有一个length属性，保存着历史记录的数量。这个数量包括所有的历史记录，即所有的向前和向后的记录。对于加载到窗口、标签页或者框架的第一个页面而言，history的length为0。可以像下面这样检查用户是否一开始就打开了你的页面。 123if(history.length == 0){ dosomething} ​ 虽然 history 并不常用，但是在创建自定义前进后退按钮，以及检测当前页面是不是用户历史记录中的第一个页面还是非常有用的。 当页面URL改变时，就会生成一条历史记录。在IE8+、Opera、FIrefox以及Safari3+和Chrome中，这里所说的改变包括URL中的hash值的变化（因此设置location.hash会在上述这些浏览器生成一条新的历史记录） 总结浏览器对象模型（BOM）以window对象以依托，表示浏览器可视窗口以及页面可是区域。同时window对象还是 ECMAScript 中的Global对象，因而所有全局变量核函数都是他的属性，并且所有的原生构造函数以及其他函数也都存在与他的命名空间。本文讨论了下列BOM组成: 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或名字来访问。 有一些窗口指针可以用来引用其他框架，包括父框架 top对象始终指向最外围的框架，也就是整个浏览器的窗口。 使用 location 对象可以通过编程方式来访问浏览器的导航系统。设置响应的属性，可以逐段或者整体修改浏览器的URL 调用 replace() 方法可以导航到一个新的URL，同时该URL会替换历史记录中当前显示的页面，就是意味着不会修改历史记录 navigator 对象提供了与浏览器相关的信息。到底提供了哪些信息很大一部分上取决于浏览器；不过也有一些大家都有的属性（如userAgen）存在于所有的浏览器当中 ​ BOM中还有两个对象：screen和history，但他们的功能有限。screen对象中保存着与客户端显示器有关的信息，这些信息一般都只用于站点分析。history 对象为开发者访问浏览器历史记录提供了一个小间隙，开发人员可以根据这个判断历史记录的数量，也可以在历史记录中前后任意跳转。","link":"/2020/01/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1-BOM/"},{"title":"Echarts各个配置详细说明","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738theme = { // 全图默认背景 // backgroundColor: 'rgba(0,0,0,0)', // 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], // 图表标题 title: { x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: { fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 }, subtextStyle: { color: '#aaa' // 副标题文字颜色 } }, // 图例 legend: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: { color: '#333' // 图例文字颜色 } }, // 值域 dataRange: { orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: { color: '#333' // 值域文字颜色 } }, toolbox: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : {}, // 自定义图片icon featureTitle : { mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' } }, // 提示框 tooltip: { trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : { // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' }, shadowStyle : { // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 } }, textStyle: { color: '#fff' } }, // 区域缩放控制器 dataZoom: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: {number}, // 水平安放位置，默认为根据grid参数适配，可选为： // {number}（x坐标，单位px） // y: {number}, // 垂直安放位置，默认为根据grid参数适配，可选为： // {number}（y坐标，单位px） // width: {number}, // 指定宽度，横向布局时默认为根据grid参数适配 // height: {number}, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 }, // 网格 grid: { x: 80, y: 60, x2: 80, y2: 60, // width: {totalWidth} - x - x2, // height: {totalHeight} - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' }, // 类目轴 categoryAxis: { position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, // 数值型坐标轴默认参数 valueAxis: { position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: {}, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, polar : { center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : { show: true, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitArea : { show : true, areaStyle : { color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } }, splitLine : { show : true, lineStyle : { width : 1, color : '#ccc' } } }, // 柱形图默认参数 bar: { barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: { normal: { // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, // 折线图默认参数 line: { itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle: { width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } }, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） }, // K线图默认参数 k: { // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: { normal: { color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: { width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 } }, emphasis: { // color: 各异, // color0: 各异 } } }, // 散点图默认参数 scatter: { //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000,// 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异' label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, // 雷达图默认参数 radar : { itemStyle: { normal: { // color: 各异, label: { show: false }, lineStyle: { width: 2, type: 'solid' } }, emphasis: { // color: 各异, label: { show: false } } }, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 }, // 饼图默认参数 pie: { center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, label: { show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: true, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } }, emphasis: { // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: { show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: false, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } } } }, map: { mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: { x : 'center', y : 'center' // width // 自适应 // height // 自适应 }, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: { color: '#ccc'//rgba(135,206,250,0.8) }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } }, emphasis: { // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: { color: 'rgba(255,215,0,0.8)' }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } } } }, force : { // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: { normal: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : { brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' }, linkStyle : { strokeColor : '#5182ab' } }, emphasis: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : {}, linkStyle : {} } } }, chord : { radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : { normal : { label : { show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 1, color : '#666' } } }, emphasis : { lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 2, color : '#333' } } } } }, island: { r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% }, markPoint : { symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: { normal: { // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: { show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: 各异 label: { show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, markLine : { // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: { normal: { // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: { show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: { // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, lineStyle: { // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异 label: { show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : {} } } }, textStyle: { decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut}","link":"/2019/12/24/Echarts%E5%90%84%E4%B8%AA%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E/"},{"title":"编译原理学习-第二节","text":"首先带着以下问题进行学习 1．编译程序各模块主要功能是什么？2．编译过程引入“前段/后端”概念的好处？3．假设两个团队分别各自开发同一语言编译器，邀请你作为评审专家，谈谈你优先考虑的几个因素？4．理解文法与语言的关系5．空符号串ε的理解6．两个符号串乘积运算与离散数学中集合里哪个运算相似？7．设Σ={a,b}，则Σn 表示什么？用一句通俗的话描述8．闭包与正闭包表示的集合范围关系。判断题1、 编译程序的生成目标代码若为机器语言，则可直接运行。（）2、 编译程序的八大模块中，只有目标代码生成属于后端。（）3、符号串x=AB，则其方幂x3 = ABABAB， x0=0 （ ）4、Σn表示字母表中长度为n的所有串构成的集合。（ ）5、文法是描述语言语法规则的一种工具（ ）","link":"/2020/03/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E8%8A%82/"},{"title":"算法数据结构学习-排序算法","text":"","link":"/2020/03/11/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"盒模型","slug":"盒模型","link":"/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"padding","slug":"padding","link":"/tags/padding/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"事件","slug":"事件","link":"/tags/%E4%BA%8B%E4%BB%B6/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"命令","slug":"命令","link":"/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"cookies","slug":"cookies","link":"/tags/cookies/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"session","slug":"session","link":"/tags/session/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"diff","slug":"diff","link":"/tags/diff/"},{"name":"虚拟DOM","slug":"虚拟DOM","link":"/tags/%E8%99%9A%E6%8B%9FDOM/"},{"name":"background-ground","slug":"background-ground","link":"/tags/background-ground/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"ES5","slug":"ES5","link":"/tags/ES5/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"源码阅读","slug":"源码阅读","link":"/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"}],"categories":[{"name":"编译原理","slug":"编译原理","link":"/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"算法/位运算","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]}